<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `nom` crate."><meta name="keywords" content="rust, rustlang, rust-lang, nom"><title>nom - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../nom/index.html'><img src='../rust-logo.png' alt='logo' width='100'></a><p class='location'>Crate nom</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all nom's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'nom', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/nom/lib.rs.html#1-471' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>nom</a></span></h1><div class='docblock'><h1 id="nom-eating-data-byte-by-byte" class="section-header"><a href="#nom-eating-data-byte-by-byte">nom, eating data byte by byte</a></h1>
<p>nom is a parser combinator library with a focus on safe parsing,
streaming patterns, and as much as possible zero copy.</p>
<h2 id="example" class="section-header"><a href="#example">Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nom</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>,<span class="ident">PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Color</span> {
  <span class="kw">pub</span> <span class="ident">red</span>:     <span class="ident">u8</span>,
  <span class="kw">pub</span> <span class="ident">green</span>:   <span class="ident">u8</span>,
  <span class="kw">pub</span> <span class="ident">blue</span>:    <span class="ident">u8</span>,
}

<span class="kw">fn</span> <span class="ident">from_hex</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u8</span>, <span class="ident">std</span>::<span class="ident">num</span>::<span class="ident">ParseIntError</span><span class="op">&gt;</span> {
  <span class="ident">u8</span>::<span class="ident">from_str_radix</span>(<span class="ident">input</span>, <span class="number">16</span>)
}

<span class="kw">fn</span> <span class="ident">is_hex_digit</span>(<span class="ident">c</span>: <span class="ident">char</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
  <span class="ident">c</span>.<span class="ident">is_digit</span>(<span class="number">16</span>)
}

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">hex_primary</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">u8</span><span class="op">&gt;</span>,
  <span class="macro">map_res</span><span class="macro">!</span>(<span class="macro">take_while_m_n</span><span class="macro">!</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="ident">is_hex_digit</span>), <span class="ident">from_hex</span>)
);

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">hex_color</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">Color</span><span class="op">&gt;</span>,
  <span class="macro">do_parse</span><span class="macro">!</span>(
           <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;#&quot;</span>)   <span class="op">&gt;&gt;</span>
    <span class="ident">red</span>:   <span class="ident">hex_primary</span> <span class="op">&gt;&gt;</span>
    <span class="ident">green</span>: <span class="ident">hex_primary</span> <span class="op">&gt;&gt;</span>
    <span class="ident">blue</span>:  <span class="ident">hex_primary</span> <span class="op">&gt;&gt;</span>
    (<span class="ident">Color</span> { <span class="ident">red</span>, <span class="ident">green</span>, <span class="ident">blue</span> })
  )
);

<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">hex_color</span>(<span class="string">&quot;#2F14DF&quot;</span>), <span class="prelude-val">Ok</span>((<span class="string">&quot;&quot;</span>, <span class="ident">Color</span> {
    <span class="ident">red</span>: <span class="number">47</span>,
    <span class="ident">green</span>: <span class="number">20</span>,
    <span class="ident">blue</span>: <span class="number">223</span>,
  })));
}</pre></div>
<p>The code is available on <a href="https://github.com/Geal/nom">Github</a></p>
<p>There are a few <a href="https://github.com/Geal/nom/tree/master/doc">guides</a> with more details
about <a href="https://github.com/Geal/nom/blob/master/doc/how_nom_macros_work.md">the design of nom</a>,
<a href="https://github.com/Geal/nom/blob/master/doc/making_a_new_parser_from_scratch.md">how to write parsers</a>,
or the <a href="https://github.com/Geal/nom/blob/master/doc/error_management.md">error management system</a>.</p>
<p><strong>Looking for a specific combinator? Read the
<a href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md">&quot;choose a combinator&quot; guide</a></strong></p>
<p>If you are upgrading to nom 2.0, please read the
<a href="https://github.com/Geal/nom/blob/master/doc/upgrading_to_nom_2.md">migration document</a>.</p>
<p>If you are upgrading to nom 4.0, please read the
<a href="https://github.com/Geal/nom/blob/master/doc/upgrading_to_nom_4.md">migration document</a>.</p>
<p>See also the <a href="https://github.com/Geal/nom/blob/master/doc/FAQ.md">FAQ</a>.</p>
<h2 id="parser-combinators" class="section-header"><a href="#parser-combinators">Parser combinators</a></h2>
<p>Parser combinators are an approach to parsers that is very different from
software like <a href="https://en.wikipedia.org/wiki/Lex_(software)">lex</a> and
<a href="https://en.wikipedia.org/wiki/Yacc">yacc</a>. Instead of writing the grammar
in a separate file and generating the corresponding code, you use very small
functions with very specific purpose, like &quot;take 5 bytes&quot;, or &quot;recognize the
word 'HTTP'&quot;, and assemble then in meaningful patterns like &quot;recognize
'HTTP', then a space, then a version&quot;.
The resulting code is small, and looks like the grammar you would have
written with other parser approaches.</p>
<p>This has a few advantages:</p>
<ul>
<li>the parsers are small and easy to write</li>
<li>the parsers components are easy to reuse (if they're general enough, please add them to nom!)</li>
<li>the parsers components are easy to test separately (unit tests and property-based tests)</li>
<li>the parser combination code looks close to the grammar you would have written</li>
<li>you can build partial parsers, specific to the data you need at the moment, and ignore the rest</li>
</ul>
<p>Here is an example of one such parser, to recognize text between parentheses:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nom</span>;

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">parens</span>, <span class="macro">delimited</span><span class="macro">!</span>(<span class="macro">char</span><span class="macro">!</span>(<span class="string">&#39;(&#39;</span>), <span class="macro">is_not</span><span class="macro">!</span>(<span class="string">&quot;)&quot;</span>), <span class="macro">char</span><span class="macro">!</span>(<span class="string">&#39;)&#39;</span>)));</pre></div>
<p>It defines a function named <code>parens</code>, which will recognize a sequence of the character <code>(</code>, the longest byte array not containing <code>)</code>, then the character <code>)</code>, and will return the byte array in the middle.</p>
<p>Here is another parser, written without using nom's macros this time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nom</span>;

<span class="kw">use</span> <span class="ident">nom</span>::{<span class="ident">IResult</span>,<span class="prelude-val">Err</span>,<span class="ident">Needed</span>};

<span class="kw">fn</span> <span class="ident">take4</span>(<span class="ident">i</span>:<span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-&gt;</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span>{
  <span class="kw">if</span> <span class="ident">i</span>.<span class="ident">len</span>() <span class="op">&lt;</span> <span class="number">4</span> {
    <span class="prelude-val">Err</span>(<span class="prelude-val">Err</span>::<span class="ident">Incomplete</span>(<span class="ident">Needed</span>::<span class="ident">Size</span>(<span class="number">4</span>)))
  } <span class="kw">else</span> {
    <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="ident">i</span>[<span class="number">4</span>..],<span class="kw-2">&amp;</span><span class="ident">i</span>[<span class="number">0</span>..<span class="number">4</span>]))
  }
}</pre></div>
<p>This function takes a byte array as input, and tries to consume 4 bytes.
Writing all the parsers manually, like this, is dangerous, despite Rust's safety features. There
are still a lot of mistakes one can make. That's why nom provides a list of macros to help in
developing parsers.</p>
<p>With macros, you would write it like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nom</span>;

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">take4</span>, <span class="macro">take</span><span class="macro">!</span>(<span class="number">4</span>));</pre></div>
<p>A parser in nom is a function which, for an input type <code>I</code>, an output type <code>O</code>
and an optional error type <code>E</code>, will have the following signature:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">fn</span> <span class="ident">parser</span>(<span class="ident">input</span>: <span class="ident">I</span>) <span class="op">-&gt;</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">O</span>, <span class="ident">E</span><span class="op">&gt;</span>;</pre></div>
<p>Or like this, if you don't want to specify a custom error type (it will be <code>u32</code> by default):</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">fn</span> <span class="ident">parser</span>(<span class="ident">input</span>: <span class="ident">I</span>) <span class="op">-&gt;</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">O</span><span class="op">&gt;</span>;</pre></div>
<p><code>IResult</code> is an alias for the <code>Result</code> type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">nom</span>::{<span class="ident">Needed</span>, <span class="ident">Context</span>};

<span class="kw">type</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">O</span>, <span class="ident">E</span> <span class="op">=</span> <span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(<span class="ident">I</span>, <span class="ident">O</span>), <span class="prelude-val">Err</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">E</span><span class="op">&gt;&gt;</span>;

<span class="kw">enum</span> <span class="prelude-val">Err</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">E</span> <span class="op">=</span> <span class="ident">u32</span><span class="op">&gt;</span> {
  <span class="ident">Incomplete</span>(<span class="ident">Needed</span>),
  <span class="ident">Error</span>(<span class="ident">Context</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">E</span><span class="op">&gt;</span>),
  <span class="ident">Failure</span>(<span class="ident">Context</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">E</span><span class="op">&gt;</span>),
}</pre></div>
<p>It can have the following values:</p>
<ul>
<li>a correct result <code>Ok((I,O))</code> with the first element being the remaining of the input (not parsed yet), and the second the output value;</li>
<li>an error <code>Err(Err::Error(c))</code> with <code>c</code> an enum that contains an error code with its position in the input, and optionally a chain of accumulated errors;</li>
<li>an error <code>Err(Err::Incomplete(Needed))</code> indicating that more input is necessary. <code>Needed</code> can indicate how much data is needed</li>
<li>an error <code>Err(Err::Failure(c))</code>. It works like the <code>Error</code> case, except it indicates an unrecoverable error: we cannot backtrack and test another parser</li>
</ul>
<p>Please refer to the [documentation][doc] for an exhaustive list of parsers. See also the
<a href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md">&quot;choose a combinator&quot; guide</a>**.</p>
<h2 id="making-new-parsers-with-macros" class="section-header"><a href="#making-new-parsers-with-macros">Making new parsers with macros</a></h2>
<p>Macros are the main way to make new parsers by combining other ones. Those macros accept other macros or function names as arguments. You then need to make a function out of that combinator with <strong><code>named!</code></strong>, or a closure with <strong><code>closure!</code></strong>. Here is how you would do, with the <strong><code>tag!</code></strong> and <strong><code>take!</code></strong> combinators:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">abcd_parser</span>, <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)); <span class="comment">// will consume bytes if the input begins with &quot;abcd&quot;</span>

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">take_10</span>, <span class="macro">take</span><span class="macro">!</span>(<span class="number">10</span>));        <span class="comment">// will consume and return 10 bytes of input</span></pre></div>
<p>The <strong><code>named!</code></strong> macro can take three different syntaxes:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">my_function</span>( <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] ) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>));

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">my_function</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span>, <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>));

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">my_function</span>, <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)); <span class="comment">// when you know the parser takes &amp;[u8] as input, and returns &amp;[u8] as output</span></pre></div>
<p><strong>IMPORTANT NOTE</strong>: Rust's macros can be very sensitive to the syntax, so you may encounter an error compiling parsers like this one:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">my_function</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;&gt;</span>, <span class="macro">many0</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)));
</pre></div>
<p>You will get the following error: <code>error: expected an item keyword</code>. This
happens because <code>&gt;&gt;</code> is seen as an operator, so the macro parser does not
recognize what we want. There is a way to avoid it, by inserting a space:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">my_function</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">&gt;</span>, <span class="macro">many0</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)));</pre></div>
<p>This will compile correctly. I am very sorry for this inconvenience.</p>
<h2 id="combining-parsers" class="section-header"><a href="#combining-parsers">Combining parsers</a></h2>
<p>There are more high level patterns, like the <strong><code>alt!</code></strong> combinator, which provides a choice between multiple parsers. If one branch fails, it tries the next, and returns the result of the first parser that succeeds:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">alt_tags</span>, <span class="macro">alt</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>) <span class="op">|</span> <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;efgh&quot;</span>)));

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">alt_tags</span>(<span class="string">b&quot;abcdxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;xxx&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;abcd&quot;</span>[..])));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">alt_tags</span>(<span class="string">b&quot;efghxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;xxx&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;efgh&quot;</span>[..])));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">alt_tags</span>(<span class="string">b&quot;ijklxxx&quot;</span>), <span class="prelude-val">Err</span>(<span class="ident">nom</span>::<span class="prelude-val">Err</span>::<span class="ident">Error</span>(<span class="macro">error_position</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;ijklxxx&quot;</span>[..], <span class="ident">nom</span>::<span class="ident">ErrorKind</span>::<span class="ident">Alt</span>))));</pre></div>
<p>The pipe <code>|</code> character is used as separator.</p>
<p>The <strong><code>opt!</code></strong> combinator makes a parser optional. If the child parser returns an error, <strong><code>opt!</code></strong> will succeed and return None:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">named</span><span class="macro">!</span>( <span class="ident">abcd_opt</span><span class="op">&lt;</span> <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">&gt;</span>, <span class="macro">opt</span><span class="macro">!</span>( <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>) ) );

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">abcd_opt</span>(<span class="string">b&quot;abcdxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;xxx&quot;</span>[..], <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;abcd&quot;</span>[..]))));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">abcd_opt</span>(<span class="string">b&quot;efghxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;efghxxx&quot;</span>[..], <span class="prelude-val">None</span>)));</pre></div>
<p><strong><code>many0!</code></strong> applies a parser 0 or more times, and returns a vector of the aggregated results:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>;

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">multi</span><span class="op">&lt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">&gt;</span>, <span class="macro">many0</span><span class="macro">!</span>( <span class="macro">map_res</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>( <span class="string">&quot;abcd&quot;</span> ), <span class="ident">str</span>::<span class="ident">from_utf8</span>) ) );
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="string">b&quot;abcdef&quot;</span>;
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="string">b&quot;abcdabcdef&quot;</span>;
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="string">b&quot;azerty&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">multi</span>(<span class="ident">a</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;ef&quot;</span>[..],     <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;abcd&quot;</span>])));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">multi</span>(<span class="ident">b</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;ef&quot;</span>[..],     <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;abcd&quot;</span>])));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">multi</span>(<span class="ident">c</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;azerty&quot;</span>[..], <span class="ident">Vec</span>::<span class="ident">new</span>())));</pre></div>
<p>Here are some basic combining macros available:</p>
<ul>
<li><strong><code>opt!</code></strong>: will make the parser optional (if it returns the <code>O</code> type, the new parser returns <code>Option&lt;O&gt;</code>)</li>
<li><strong><code>many0!</code></strong>: will apply the parser 0 or more times (if it returns the <code>O</code> type, the new parser returns <code>Vec&lt;O&gt;</code>)</li>
<li><strong><code>many1!</code></strong>: will apply the parser 1 or more times</li>
</ul>
<p>There are more complex (and more useful) parsers like <code>do_parse!</code> and <code>tuple!</code>, which are used to apply a series of parsers then assemble their results.</p>
<p>Example with <code>tuple!</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">nom</span>::{<span class="ident">ErrorKind</span>, <span class="ident">Needed</span>,<span class="ident">be_u16</span>};

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">tpl</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], (<span class="ident">u16</span>, <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">&gt;</span>,
  <span class="macro">tuple</span><span class="macro">!</span>(
    <span class="ident">be_u16</span> ,
    <span class="macro">take</span><span class="macro">!</span>(<span class="number">3</span>),
    <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;fg&quot;</span>)
  )
);

<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">tpl</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;abcdefgh&quot;</span>[..]),
  <span class="prelude-val">Ok</span>((
    <span class="kw-2">&amp;</span><span class="string">b&quot;h&quot;</span>[..],
    (<span class="number">0x6162u16</span>, <span class="kw-2">&amp;</span><span class="string">b&quot;cde&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;fg&quot;</span>[..])
  ))
);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">tpl</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;abcde&quot;</span>[..]), <span class="prelude-val">Err</span>(<span class="ident">nom</span>::<span class="prelude-val">Err</span>::<span class="ident">Incomplete</span>(<span class="ident">Needed</span>::<span class="ident">Size</span>(<span class="number">2</span>))));
<span class="kw">let</span> <span class="ident">input</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="string">b&quot;abcdejk&quot;</span>[..];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">tpl</span>(<span class="ident">input</span>), <span class="prelude-val">Err</span>(<span class="ident">nom</span>::<span class="prelude-val">Err</span>::<span class="ident">Error</span>(<span class="macro">error_position</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">input</span>[<span class="number">5</span>..], <span class="ident">ErrorKind</span>::<span class="ident">Tag</span>))));</pre></div>
<p>Example with <code>do_parse!</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">nom</span>::<span class="ident">IResult</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">A</span> {
  <span class="ident">a</span>: <span class="ident">u8</span>,
  <span class="ident">b</span>: <span class="ident">u8</span>
}

<span class="kw">fn</span> <span class="ident">ret_int1</span>(<span class="ident">i</span>:<span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-&gt;</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">u8</span><span class="op">&gt;</span> { <span class="prelude-val">Ok</span>((<span class="ident">i</span>,<span class="number">1</span>)) }
<span class="kw">fn</span> <span class="ident">ret_int2</span>(<span class="ident">i</span>:<span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-&gt;</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">u8</span><span class="op">&gt;</span> { <span class="prelude-val">Ok</span>((<span class="ident">i</span>,<span class="number">2</span>)) }

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">f</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>],<span class="ident">A</span><span class="op">&gt;</span>,
  <span class="macro">do_parse</span><span class="macro">!</span>(    <span class="comment">// the parser takes a byte array as input, and returns an A struct</span>
    <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)       <span class="op">&gt;&gt;</span>      <span class="comment">// begins with &quot;abcd&quot;</span>
    <span class="macro">opt</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)) <span class="op">&gt;&gt;</span>      <span class="comment">// this is an optional parser</span>
    <span class="ident">aa</span>: <span class="ident">ret_int1</span>       <span class="op">&gt;&gt;</span>      <span class="comment">// the return value of ret_int1, if it does not fail, will be stored in aa</span>
    <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;efgh&quot;</span>)       <span class="op">&gt;&gt;</span>
    <span class="ident">bb</span>: <span class="ident">ret_int2</span>       <span class="op">&gt;&gt;</span>
    <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;efgh&quot;</span>)       <span class="op">&gt;&gt;</span>

    (<span class="ident">A</span>{<span class="ident">a</span>: <span class="ident">aa</span>, <span class="ident">b</span>: <span class="ident">bb</span>})          <span class="comment">// the final tuple will be able to use the variable defined previously</span>
  )
);

<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">f</span>(<span class="string">b&quot;abcdabcdefghefghX&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">r</span>, <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;X&quot;</span>[..], <span class="ident">A</span>{<span class="ident">a</span>: <span class="number">1</span>, <span class="ident">b</span>: <span class="number">2</span>})));

<span class="kw">let</span> <span class="ident">r2</span> <span class="op">=</span> <span class="ident">f</span>(<span class="string">b&quot;abcdefghefghX&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">r2</span>, <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;X&quot;</span>[..], <span class="ident">A</span>{<span class="ident">a</span>: <span class="number">1</span>, <span class="ident">b</span>: <span class="number">2</span>})));</pre></div>
<p>The double right arrow <code>&gt;&gt;</code> is used as separator between every parser in the sequence, and the last closure can see the variables storing the result of parsers. Unless the specified return type is already a tuple, the final line should be that type wrapped in a tuple.</p>
<p>More examples of <a href="macro.do_parse.html"><code>do_parse!</code></a> and <a href="macro.tuple.html"><code>tuple!</code></a> usage can be found in the <a href="tests/ini.rs">INI file parser example</a>.</p>
<p><strong>Going further:</strong> read the <a href="https://github.com/Geal/nom/tree/master/doc">guides</a>!</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use self::<a class="mod" href="../nom/simple_errors/index.html" title="mod nom::simple_errors">simple_errors</a>::*;</code></td></tr><tr><td><code>pub use self::<a class="mod" href="../nom/methods/index.html" title="mod nom::methods">methods</a>::*;</code></td></tr><tr><td><code>pub use self::<a class="mod" href="../nom/bits/index.html" title="mod nom::bits">bits</a>::*;</code></td></tr><tr><td><code>pub use self::<a class="mod" href="../nom/whitespace/index.html" title="mod nom::whitespace">whitespace</a>::*;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="bits/index.html" title='nom::bits mod'>bits</a></td><td class='docblock-short'><p>Bit level parsers and combinators</p>
</td></tr><tr class='module-item'><td><a class="mod" href="lib/index.html" title='nom::lib mod'>lib</a></td><td class='docblock-short'><p>Lib module to re-export everything needed from <code>std</code> or <code>core</code>/<code>alloc</code>. This is how <code>serde</code> does
it, albeit there it is not public.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="methods/index.html" title='nom::methods mod'>methods</a></td><td class='docblock-short'><p>Method macro combinators</p>
</td></tr><tr class='module-item'><td><a class="mod" href="simple_errors/index.html" title='nom::simple_errors mod'>simple_errors</a></td><td class='docblock-short'><p>Error management</p>
</td></tr><tr class='module-item'><td><a class="mod" href="types/index.html" title='nom::types mod'>types</a></td><td class='docblock-short'><p>Custom input types</p>
</td></tr><tr class='module-item'><td><a class="mod" href="whitespace/index.html" title='nom::whitespace mod'>whitespace</a></td><td class='docblock-short'><p>Support for whitespace delimited formats</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.add_return_error.html" title='nom::add_return_error macro'>add_return_error</a></td><td class='docblock-short'><p>Add an error if the child parser fails</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.alt.html" title='nom::alt macro'>alt</a></td><td class='docblock-short'><p>Try a list of parsers and return the result of the first successful one</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.alt_complete.html" title='nom::alt_complete macro'>alt_complete</a></td><td class='docblock-short'><p>Is equivalent to the <code>alt!</code> combinator, except that it will not return <code>Incomplete</code>
when one of the constituting parsers returns <code>Incomplete</code>. Instead, it will try the
next alternative in the chain.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.apply.html" title='nom::apply macro'>apply</a></td><td class='docblock-short'><p>emulate function currying: <code>apply!(my_function, arg1, arg2, ...)</code> becomes <code>my_function(input, arg1, arg2, ...)</code></p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.apply_m.html" title='nom::apply_m macro'>apply_m</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p>emulate function currying for method calls on structs
<code>apply_m!(self.my_function, arg1, arg2, ...)</code> becomes <code>self.my_function(input, arg1, arg2, ...)</code></p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.bits.html" title='nom::bits macro'>bits</a></td><td class='docblock-short'><p>Transforms its byte slice input into a bit stream for the underlying parser. This allows the
given bit stream parser to work on a byte slice input.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.bytes.html" title='nom::bytes macro'>bytes</a></td><td class='docblock-short'><p>Counterpart to bits, bytes! transforms its bit stream input into a byte slice for the underlying
parser, allowing byte-slice parsers to work on bit streams.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.call.html" title='nom::call macro'>call</a></td><td class='docblock-short'><p>Used to wrap common expressions and function as macros</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.call_m.html" title='nom::call_m macro'>call_m</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p>Used to called methods then move self back into self</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.char.html" title='nom::char macro'>char</a></td><td class='docblock-short'><p>matches one character: `char!(char) =&gt; &amp;<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html" title="u8">u8</a> -&gt; IResult&lt;&amp;<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html" title="u8">u8</a>, char&gt;</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.closure.html" title='nom::closure macro'>closure</a></td><td class='docblock-short'><p>Wraps a parser in a closure</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.complete.html" title='nom::complete macro'>complete</a></td><td class='docblock-short'><p>replaces a <code>Incomplete</code> returned by the child parser
with an <code>Error</code></p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.cond.html" title='nom::cond macro'>cond</a></td><td class='docblock-short'><p><code>cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.cond_reduce.html" title='nom::cond_reduce macro'>cond_reduce</a></td><td class='docblock-short'><p><code>cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
Conditional combinator with error</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.cond_with_error.html" title='nom::cond_with_error macro'>cond_with_error</a></td><td class='docblock-short'><p><code>cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.count.html" title='nom::count macro'>count</a></td><td class='docblock-short'><p><code>count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the child parser a specified number of times</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.count_fixed.html" title='nom::count_fixed macro'>count_fixed</a></td><td class='docblock-short'><p><code>count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;</code>
Applies the child parser a fixed number of times and returns a fixed size array
The type must be specified and it must be <code>Copy</code></p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.dbg.html" title='nom::dbg macro'>dbg</a></td><td class='docblock-short'><p>Prints a message if the parser fails</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.dbg_dmp.html" title='nom::dbg_dmp macro'>dbg_dmp</a></td><td class='docblock-short'><p>Prints a message and the input if the parser fails</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.delimited.html" title='nom::delimited macro'>delimited</a></td><td class='docblock-short'><p><code>delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
delimited(opening, X, closing) returns X</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.do_parse.html" title='nom::do_parse macro'>do_parse</a></td><td class='docblock-short'><p><code>do_parse!(I-&gt;IResult&lt;I,A&gt; &gt;&gt; I-&gt;IResult&lt;I,B&gt; &gt;&gt; ... I-&gt;IResult&lt;I,X&gt; , ( O ) ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
do_parse applies sub parsers in a sequence.
it can store intermediary results and make them available
for later parsers</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.eat_separator.html" title='nom::eat_separator macro'>eat_separator</a></td><td class='docblock-short'><p>helper macros to build a separator parser</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.eof.html" title='nom::eof macro'>eof</a></td><td class='docblock-short'><p><code>eof!()</code> returns its input if it is at the end of input data</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.error_node_position.html" title='nom::error_node_position macro'>error_node_position</a></td><td class='docblock-short'><p>creates a parse error from a <code>nom::ErrorKind</code>,
the position in the input and the next error in
the parsing tree.
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.error_position.html" title='nom::error_position macro'>error_position</a></td><td class='docblock-short'><p>creates a parse error from a <code>nom::ErrorKind</code>
and the position in the input
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.escaped.html" title='nom::escaped macro'>escaped</a></td><td class='docblock-short'><p><code>escaped!(T -&gt; IResult&lt;T, T&gt;, U, T -&gt; IResult&lt;T, T&gt;) =&gt; T -&gt; IResult&lt;T, T&gt; where T: InputIter, U: AsChar</code>
matches a byte string with escaped characters.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.escaped_transform.html" title='nom::escaped_transform macro'>escaped_transform</a></td><td class='docblock-short'><p><code>escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;</code>
matches a byte string with escaped characters.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.exact.html" title='nom::exact macro'>exact</a></td><td class='docblock-short'><p><code>exact!()</code> will fail if the child parser does not consume the whole data</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.expr_opt.html" title='nom::expr_opt macro'>expr_opt</a></td><td class='docblock-short'><p><code>expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Option<T> and returns a Ok((I,T)) if Some</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.expr_res.html" title='nom::expr_res macro'>expr_res</a></td><td class='docblock-short'><p><code>expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Result&lt;T,E&gt; and returns a Ok((I,T)) if Ok</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.fix_error.html" title='nom::fix_error macro'>fix_error</a></td><td class='docblock-short'><p>translate parser result from IResult&lt;I,O,u32&gt; to IResult&lt;I,O,E&gt; with a custom type</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.flat_map.html" title='nom::flat_map macro'>flat_map</a></td><td class='docblock-short'><p><code>flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.fold_many0.html" title='nom::fold_many0 macro'>fold_many0</a></td><td class='docblock-short'><p><code>fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 0 or more times and folds the list of return values</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.fold_many1.html" title='nom::fold_many1 macro'>fold_many1</a></td><td class='docblock-short'><p><code>fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 1 or more times and folds the list of return values</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.fold_many_m_n.html" title='nom::fold_many_m_n macro'>fold_many_m_n</a></td><td class='docblock-short'><p><code>fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser between m and n times (n included) and folds the list of return value</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.i16.html" title='nom::i16 macro'>i16</a></td><td class='docblock-short'><p>if the parameter is nom::Endianness::Big, parse a big endian i16 integer,
otherwise a little endian i16 integer</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.i32.html" title='nom::i32 macro'>i32</a></td><td class='docblock-short'><p>if the parameter is nom::Endianness::Big, parse a big endian i32 integer,
otherwise a little endian i32 integer</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.i64.html" title='nom::i64 macro'>i64</a></td><td class='docblock-short'><p>if the parameter is nom::Endianness::Big, parse a big endian i64 integer,
otherwise a little endian i64 integer</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.i128.html" title='nom::i128 macro'>i128</a></td><td class='docblock-short'><p>if the parameter is nom::Endianness::Big, parse a big endian i64 integer,
otherwise a little endian i64 integer</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.is_a.html" title='nom::is_a macro'>is_a</a></td><td class='docblock-short'><p><code>is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that appear in the provided array</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.is_a_s.html" title='nom::is_a_s macro'>is_a_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that appear in the provided array</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.is_not.html" title='nom::is_not macro'>is_not</a></td><td class='docblock-short'><p><code>is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that do not appear in the provided array</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.is_not_s.html" title='nom::is_not_s macro'>is_not_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that do not appear in the provided array</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.length_bytes.html" title='nom::length_bytes macro'>length_bytes</a></td><td class='docblock-short'><p><code>length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
Gets a number from the first parser, then extracts that many bytes from the
remaining stream</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.length_count.html" title='nom::length_count macro'>length_count</a></td><td class='docblock-short'><p><code>length_count!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, then applies the second parser that many times</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.length_data.html" title='nom::length_data macro'>length_data</a></td><td class='docblock-short'><p><code>length_data!(I -&gt; IResult&lt;I, nb&gt;) =&gt; O</code></p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.length_value.html" title='nom::length_value macro'>length_value</a></td><td class='docblock-short'><p><code>length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code></p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.many0.html" title='nom::many0 macro'>many0</a></td><td class='docblock-short'><p><code>many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 0 or more times and returns the list of results in a Vec.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.many0_count.html" title='nom::many0_count macro'>many0_count</a></td><td class='docblock-short'><p><code>many0_count!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, usize&gt;</code>
Applies the parser 0 or more times and returns the number of times the parser was applied.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.many1.html" title='nom::many1 macro'>many1</a></td><td class='docblock-short'><p><code>many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 1 or more times and returns the list of results in a Vec</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.many1_count.html" title='nom::many1_count macro'>many1_count</a></td><td class='docblock-short'><p><code>many1_count!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, usize&gt;</code>
Applies the parser 1 or more times and returns the number of times the parser was applied.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.many_m_n.html" title='nom::many_m_n macro'>many_m_n</a></td><td class='docblock-short'><p><code>many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser between m and n times (n included) and returns the list of
results in a Vec</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.many_till.html" title='nom::many_till macro'>many_till</a></td><td class='docblock-short'><p><code>many_till!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (Vec&lt;O&gt;, P)&gt;</code>
Applies the first parser until the second applies. Returns a tuple containing the list
of results from the first in a Vec and the result of the second.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.map.html" title='nom::map macro'>map</a></td><td class='docblock-short'><p><code>map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function on the result of a parser</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.map_opt.html" title='nom::map_opt macro'>map_opt</a></td><td class='docblock-short'><p><code>map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning an Option on the output of a parser</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.map_res.html" title='nom::map_res macro'>map_res</a></td><td class='docblock-short'><p><code>map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning a Result on the output of a parser</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.map_res_err.html" title='nom::map_res_err macro'>map_res_err</a></td><td class='docblock-short'><p><code>map_res_err!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning a Result on the output of a parser, preserving the returned error</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.method.html" title='nom::method macro'>method</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p>Makes a method from a parser combination</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.named.html" title='nom::named macro'>named</a></td><td class='docblock-short'><p>Makes a function from a parser combination</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.named_args.html" title='nom::named_args macro'>named_args</a></td><td class='docblock-short'><p>Makes a function from a parser combination with arguments.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.named_attr.html" title='nom::named_attr macro'>named_attr</a></td><td class='docblock-short'><p>Makes a function from a parser combination, with attributes</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.nom_compile_error.html" title='nom::nom_compile_error macro'>nom_compile_error</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.nom_line.html" title='nom::nom_line macro'>nom_line</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.nom_println.html" title='nom::nom_println macro'>nom_println</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.nom_stringify.html" title='nom::nom_stringify macro'>nom_stringify</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.none_of.html" title='nom::none_of macro'>none_of</a></td><td class='docblock-short'><p>matches anything but the provided characters</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.not.html" title='nom::not macro'>not</a></td><td class='docblock-short'><p><code>not!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result only if the embedded parser returns Error or Err(Err::Incomplete)
does not consume the input</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.one_of.html" title='nom::one_of macro'>one_of</a></td><td class='docblock-short'><p>matches one of the provided characters</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.opt.html" title='nom::opt macro'>opt</a></td><td class='docblock-short'><p><code>opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
make the underlying parser optional</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.opt_res.html" title='nom::opt_res macro'>opt_res</a></td><td class='docblock-short'><p><code>opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;</code>
make the underlying parser optional</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.pair.html" title='nom::pair macro'>pair</a></td><td class='docblock-short'><p><code>pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
pair(X,Y), returns (x,y)</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.parse_to.html" title='nom::parse_to macro'>parse_to</a></td><td class='docblock-short'><p><code>parse_to!(O) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
uses the <code>parse</code> method from <code>std::str::FromStr</code> to convert the current
input to the specified type</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.peek.html" title='nom::peek macro'>peek</a></td><td class='docblock-short'><p><code>peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result without consuming the input</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.permutation.html" title='nom::permutation macro'>permutation</a></td><td class='docblock-short'><p><code>permutation!(I -&gt; IResult&lt;I,A&gt;, I -&gt; IResult&lt;I,B&gt;, ... I -&gt; IResult&lt;I,X&gt; ) =&gt; I -&gt; IResult&lt;I, (A,B,...X)&gt;</code>
applies its sub parsers in a sequence, but independent from their order
this parser will only succeed if all of its sub parsers succeed</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.preceded.html" title='nom::preceded macro'>preceded</a></td><td class='docblock-short'><p><code>preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
preceded(opening, X) returns X</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.recognize.html" title='nom::recognize macro'>recognize</a></td><td class='docblock-short'><p><code>recognize!(I -&gt; IResult&lt;I, O&gt; ) =&gt; I -&gt; IResult&lt;I, I&gt;</code>
if the child parser was successful, return the consumed input as produced value</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.return_error.html" title='nom::return_error macro'>return_error</a></td><td class='docblock-short'><p>Prevents backtracking if the child parser fails</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.sep.html" title='nom::sep macro'>sep</a></td><td class='docblock-short'><p>sep is the parser rewriting macro for whitespace separated formats</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.separated_list.html" title='nom::separated_list macro'>separated_list</a></td><td class='docblock-short'><p><code>separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_list(sep, X) returns Vec<X> will return Incomplete if there may be more elements</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.separated_list_complete.html" title='nom::separated_list_complete macro'>separated_list_complete</a></td><td class='docblock-short'><p><code>separated_list_complete!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
This is equivalent to the <code>separated_list!</code> combinator, except that it will return <code>Error</code>
when either the separator or element subparser returns <code>Incomplete</code>.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.separated_nonempty_list.html" title='nom::separated_nonempty_list macro'>separated_nonempty_list</a></td><td class='docblock-short'><p><code>separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_nonempty_list(sep, X) returns Vec<X> will return Incomplete if there may be more elements</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.separated_nonempty_list_complete.html" title='nom::separated_nonempty_list_complete macro'>separated_nonempty_list_complete</a></td><td class='docblock-short'><p><code>separated_nonempty_list_complete!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
This is equivalent to the <code>separated_nonempty_list!</code> combinator, except that it will return
<code>Error</code> when either the separator or element subparser returns <code>Incomplete</code>.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.separated_pair.html" title='nom::separated_pair macro'>separated_pair</a></td><td class='docblock-short'><p><code>separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
separated_pair(X,sep,Y) returns (x,y)</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.switch.html" title='nom::switch macro'>switch</a></td><td class='docblock-short'><p><code>switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
choose the next parser depending on the result of the first one, if successful,
and returns the result of the second parser</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.tag.html" title='nom::tag macro'>tag</a></td><td class='docblock-short'><p><code>tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a byte array as a suite to recognize</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.tag_bits.html" title='nom::tag_bits macro'>tag_bits</a></td><td class='docblock-short'><p>Matches the given bit pattern.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.tag_no_case.html" title='nom::tag_no_case macro'>tag_no_case</a></td><td class='docblock-short'><p><code>tag_no_case!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a case insensitive ascii string as a suite to recognize</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.tag_no_case_s.html" title='nom::tag_no_case_s macro'>tag_no_case_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>tag_no_case_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a case-insensitive string as a suite to recognize</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.tag_s.html" title='nom::tag_s macro'>tag_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a string as a suite to recognize</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take.html" title='nom::take macro'>take</a></td><td class='docblock-short'><p><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming the specified number of bytes</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_bits.html" title='nom::take_bits macro'>take_bits</a></td><td class='docblock-short'><p>Consumes the specified number of bits and returns them as the specified type.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_s.html" title='nom::take_s macro'>take_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming the specified number of characters</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_str.html" title='nom::take_str macro'>take_str</a></td><td class='docblock-short'><p><code>take_str!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;</code>
same as take! but returning a &amp;str</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_till.html" title='nom::take_till macro'>take_till</a></td><td class='docblock-short'><p><code>take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function succeeds</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_till1.html" title='nom::take_till1 macro'>take_till1</a></td><td class='docblock-short'><p><code>take_till1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest non empty list of bytes until the provided function succeeds</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_till1_s.html" title='nom::take_till1_s macro'>take_till1_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>take_till1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest non empty list of characters until the provided function succeeds</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_till_s.html" title='nom::take_till_s macro'>take_till_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>take_till_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function succeeds</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_until.html" title='nom::take_until macro'>take_until</a></td><td class='docblock-short'><p><code>take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds the specified tag.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_until1.html" title='nom::take_until1 macro'>take_until1</a></td><td class='docblock-short'><p><code>take_until1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data (at least one byte) until it finds the specified tag</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_until_and_consume.html" title='nom::take_until_and_consume macro'>take_until_and_consume</a></td><td class='docblock-short'><p><code>take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes until the specified byte sequence is found, and consumes it</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_until_and_consume1.html" title='nom::take_until_and_consume1 macro'>take_until_and_consume1</a></td><td class='docblock-short'><p><code>take_until_and_consume1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes (at least 1) until the specified byte sequence is found, and consumes it</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_until_and_consume_s.html" title='nom::take_until_and_consume_s macro'>take_until_and_consume_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and consumes it</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_until_either.html" title='nom::take_until_either macro'>take_until_either</a></td><td class='docblock-short'><p><code>take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_until_either1.html" title='nom::take_until_either1 macro'>take_until_either1</a></td><td class='docblock-short'><p><code>take_until_either1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data (at least one byte) until it finds any of the specified characters</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_until_either_and_consume.html" title='nom::take_until_either_and_consume macro'>take_until_either_and_consume</a></td><td class='docblock-short'><p><code>take_until_either_and_consume!(chars) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters, and consume it</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_until_either_and_consume1.html" title='nom::take_until_either_and_consume1 macro'>take_until_either_and_consume1</a></td><td class='docblock-short'><p><code>take_until_either_and_consume1!(chars) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data (at least one byte) until it finds any of the specified characters, and consume it</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_until_s.html" title='nom::take_until_s macro'>take_until_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and leaves it in the remaining input</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_while.html" title='nom::take_while macro'>take_while</a></td><td class='docblock-short'><p><code>take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function fails.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_while1.html" title='nom::take_while1 macro'>take_while1</a></td><td class='docblock-short'><p><code>take_while1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest (non empty) list of bytes until the provided function fails.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_while1_s.html" title='nom::take_while1_s macro'>take_while1_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest (non empty) list of characters until the provided function fails.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_while_m_n.html" title='nom::take_while_m_n macro'>take_while_m_n</a></td><td class='docblock-short'><p><code>take_while_m_n!(m: usize, n: usize, T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns a list of bytes or characters for which the provided function returns true.
the returned list's size will be at least m, and at most n</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.take_while_s.html" title='nom::take_while_s macro'>take_while_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p><code>take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function fails.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.tap.html" title='nom::tap macro'>tap</a></td><td class='docblock-short'><p><code>tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
allows access to the parser's result without affecting it</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.terminated.html" title='nom::terminated macro'>terminated</a></td><td class='docblock-short'><p><code>terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
terminated(X, closing) returns X</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.try_parse.html" title='nom::try_parse macro'>try_parse</a></td><td class='docblock-short'><p>A bit like <code>std::try!</code>, this macro will return the remaining input and
parsed value if the child parser returned <code>Ok</code>, and will do an early
return for the <code>Err</code> side.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.tuple.html" title='nom::tuple macro'>tuple</a></td><td class='docblock-short'><p><code>tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;</code>
chains parsers and assemble the sub results in a tuple.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.u16.html" title='nom::u16 macro'>u16</a></td><td class='docblock-short'><p>if the parameter is nom::Endianness::Big, parse a big endian u16 integer,
otherwise a little endian u16 integer</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.u32.html" title='nom::u32 macro'>u32</a></td><td class='docblock-short'><p>if the parameter is nom::Endianness::Big, parse a big endian u32 integer,
otherwise a little endian u32 integer</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.u64.html" title='nom::u64 macro'>u64</a></td><td class='docblock-short'><p>if the parameter is nom::Endianness::Big, parse a big endian u64 integer,
otherwise a little endian u64 integer</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.u128.html" title='nom::u128 macro'>u128</a></td><td class='docblock-short'><p>if the parameter is nom::Endianness::Big, parse a big endian u128 integer,
otherwise a little endian u128 integer</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.value.html" title='nom::value macro'>value</a></td><td class='docblock-short'><p><code>value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.verify.html" title='nom::verify macro'>verify</a></td><td class='docblock-short'><p><code>verify!(I -&gt; IResult&lt;I,O&gt;, O -&gt; bool) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns the result of the child parser if it satisfies a verification function</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.wrap_sep.html" title='nom::wrap_sep macro'>wrap_sep</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="macro" href="macro.ws.html" title='nom::ws macro'>ws</a></td><td class='docblock-short'><p><code>ws!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code></p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.CompareResult.html" title='nom::CompareResult enum'>CompareResult</a></td><td class='docblock-short'><p>indicates wether a comparison was successful, an error, or
if more data was needed</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Endianness.html" title='nom::Endianness enum'>Endianness</a></td><td class='docblock-short'><p>Configurable endianness</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Err.html" title='nom::Err enum'>Err</a></td><td class='docblock-short'><p>The <code>Err</code> enum indicates the parser was not successful</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.ErrorKind.html" title='nom::ErrorKind enum'>ErrorKind</a></td><td class='docblock-short'><p>indicates which parser returned an error</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Needed.html" title='nom::Needed enum'>Needed</a></td><td class='docblock-short'><p>Contains information on needed data if a parser returned <code>Incomplete</code></p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.AsBytes.html" title='nom::AsBytes trait'>AsBytes</a></td><td class='docblock-short'><p>casts the input type to a byte slice</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.AsChar.html" title='nom::AsChar trait'>AsChar</a></td><td class='docblock-short'><p>transforms common types to a char for basic token parsing</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.AtEof.html" title='nom::AtEof trait'>AtEof</a></td><td class='docblock-short'><p>indicates whether more data can come later in input</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Compare.html" title='nom::Compare trait'>Compare</a></td><td class='docblock-short'><p>abstracts comparison operations</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Convert.html" title='nom::Convert trait'>Convert</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="trait" href="trait.ExtendInto.html" title='nom::ExtendInto trait'>ExtendInto</a></td><td class='docblock-short'><p>abtracts something which can extend an <code>Extend</code></p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.FindSubstring.html" title='nom::FindSubstring trait'>FindSubstring</a></td><td class='docblock-short'><p>look for a substring in self</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.FindToken.html" title='nom::FindToken trait'>FindToken</a></td><td class='docblock-short'><p>look for self in the given input stream</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.HexDisplay.html" title='nom::HexDisplay trait'>HexDisplay</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="trait" href="trait.InputIter.html" title='nom::InputIter trait'>InputIter</a></td><td class='docblock-short'><p>abstracts common iteration operations on the input type</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.InputLength.html" title='nom::InputLength trait'>InputLength</a></td><td class='docblock-short'><p>abstract method to calculate the input length</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.InputTake.html" title='nom::InputTake trait'>InputTake</a></td><td class='docblock-short'><p>abstracts slicing operations</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.InputTakeAtPosition.html" title='nom::InputTakeAtPosition trait'>InputTakeAtPosition</a></td><td class='docblock-short'><p>methods to take as much input as possible until the provided function returns true for the current element</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Offset.html" title='nom::Offset trait'>Offset</a></td><td class='docblock-short'><p>useful functions to calculate the offset between slices and show a hexdump of a slice</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.ParseTo.html" title='nom::ParseTo trait'>ParseTo</a></td><td class='docblock-short'><p>used to integrate str's parse() method</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.Slice.html" title='nom::Slice trait'>Slice</a></td><td class='docblock-short'><p>slicing operations using ranges</p>
</td></tr><tr class='module-item'><td><a class="trait" href="trait.UnspecializedInput.html" title='nom::UnspecializedInput trait'>UnspecializedInput</a></td><td class='docblock-short'><p>Dummy trait used for default implementations (currently only used for <code>InputTakeAtPosition</code>).</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.alpha.html" title='nom::alpha fn'>alpha</a></td><td class='docblock-short'><p>Recognizes one or more lowercase and uppercase alphabetic characters.
For ASCII strings: a-zA-Z
For UTF8 strings, any alphabetic code point (ie, not only the ASCII ones)</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.alpha0.html" title='nom::alpha0 fn'>alpha0</a></td><td class='docblock-short'><p>Recognizes zero or more lowercase and uppercase alphabetic characters.
For ASCII strings: a-zA-Z
For UTF8 strings, any alphabetic code point (ie, not only the ASCII ones)</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.alpha1.html" title='nom::alpha1 fn'>alpha1</a></td><td class='docblock-short'><p>Recognizes one or more lowercase and uppercase alphabetic characters
For ASCII strings: a-zA-Z
For UTF8 strings, any alphabetic code point (ie, not only the ASCII ones)</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.alphanumeric.html" title='nom::alphanumeric fn'>alphanumeric</a></td><td class='docblock-short'><p>Recognizes one or more numerical and alphabetic characters
For ASCII strings: 0-9a-zA-Z
For UTF8 strings, 0-9 and any alphabetic code point (ie, not only the ASCII ones)</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.alphanumeric0.html" title='nom::alphanumeric0 fn'>alphanumeric0</a></td><td class='docblock-short'><p>Recognizes zero or more numerical and alphabetic characters.
For ASCII strings: 0-9a-zA-Z
For UTF8 strings, 0-9 and any alphabetic code point (ie, not only the ASCII ones)</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.alphanumeric1.html" title='nom::alphanumeric1 fn'>alphanumeric1</a></td><td class='docblock-short'><p>Recognizes one or more numerical and alphabetic characters.
For ASCII strings: 0-9a-zA-Z
For UTF8 strings, 0-9 and any alphabetic code point (ie, not only the ASCII ones)</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.anychar.html" title='nom::anychar fn'>anychar</a></td><td class='docblock-short'><p>matches one byte as a character. Note that the input type will
accept a <code>str</code>, but not a <code>&amp;[u8]</code>, unlike many other nom parsers.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_f32.html" title='nom::be_f32 fn'>be_f32</a></td><td class='docblock-short'><p>Recognizes big endian 4 bytes floating point number</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_f64.html" title='nom::be_f64 fn'>be_f64</a></td><td class='docblock-short'><p>Recognizes big endian 8 bytes floating point number</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_i8.html" title='nom::be_i8 fn'>be_i8</a></td><td class='docblock-short'><p>Recognizes a signed 1 byte integer (equivalent to take!(1)</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_i16.html" title='nom::be_i16 fn'>be_i16</a></td><td class='docblock-short'><p>Recognizes big endian signed 2 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_i24.html" title='nom::be_i24 fn'>be_i24</a></td><td class='docblock-short'><p>Recognizes big endian signed 3 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_i32.html" title='nom::be_i32 fn'>be_i32</a></td><td class='docblock-short'><p>Recognizes big endian signed 4 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_i64.html" title='nom::be_i64 fn'>be_i64</a></td><td class='docblock-short'><p>Recognizes big endian signed 8 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_i128.html" title='nom::be_i128 fn'>be_i128</a></td><td class='docblock-short'><p>Recognizes big endian signed 16 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_u8.html" title='nom::be_u8 fn'>be_u8</a></td><td class='docblock-short'><p>Recognizes an unsigned 1 byte integer (equivalent to take!(1)</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_u16.html" title='nom::be_u16 fn'>be_u16</a></td><td class='docblock-short'><p>Recognizes big endian unsigned 2 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_u24.html" title='nom::be_u24 fn'>be_u24</a></td><td class='docblock-short'><p>Recognizes big endian unsigned 3 byte integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_u32.html" title='nom::be_u32 fn'>be_u32</a></td><td class='docblock-short'><p>Recognizes big endian unsigned 4 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_u64.html" title='nom::be_u64 fn'>be_u64</a></td><td class='docblock-short'><p>Recognizes big endian unsigned 8 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.be_u128.html" title='nom::be_u128 fn'>be_u128</a></td><td class='docblock-short'><p>Recognizes big endian unsigned 16 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.begin.html" title='nom::begin fn'>begin</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.code_from_offset.html" title='nom::code_from_offset fn'>code_from_offset</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.crlf.html" title='nom::crlf fn'>crlf</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.digit.html" title='nom::digit fn'>digit</a></td><td class='docblock-short'><p>Recognizes one or more numerical characters: 0-9</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.digit0.html" title='nom::digit0 fn'>digit0</a></td><td class='docblock-short'><p>Recognizes zero or more numerical characters: 0-9</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.digit1.html" title='nom::digit1 fn'>digit1</a></td><td class='docblock-short'><p>Recognizes one or more numerical characters: 0-9</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.double.html" title='nom::double fn'>double</a></td><td class='docblock-short'><p>Recognizes floating point number in a byte string and returns a f64</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.double_s.html" title='nom::double_s fn'>double_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p>Recognizes floating point number in a string and returns a f64</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.eol.html" title='nom::eol fn'>eol</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.error_to_u32.html" title='nom::error_to_u32 fn'>error_to_u32</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.float.html" title='nom::float fn'>float</a></td><td class='docblock-short'><p>Recognizes floating point number in a byte string and returns a f32</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.float_s.html" title='nom::float_s fn'>float_s</a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p>Recognizes floating point number in a string and returns a f32</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.hex_digit.html" title='nom::hex_digit fn'>hex_digit</a></td><td class='docblock-short'><p>Recognizes one or more hexadecimal numerical characters: 0-9, A-F, a-f</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.hex_digit0.html" title='nom::hex_digit0 fn'>hex_digit0</a></td><td class='docblock-short'><p>Recognizes zero or more hexadecimal numerical characters: 0-9, A-F, a-f</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.hex_digit1.html" title='nom::hex_digit1 fn'>hex_digit1</a></td><td class='docblock-short'><p>Recognizes one or more hexadecimal numerical characters: 0-9, A-F, a-f</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.hex_u32.html" title='nom::hex_u32 fn'>hex_u32</a></td><td class='docblock-short'><p>Recognizes a hex-encoded integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.is_alphabetic.html" title='nom::is_alphabetic fn'>is_alphabetic</a></td><td class='docblock-short'><p>Tests if byte is ASCII alphabetic: A-Z, a-z</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.is_alphanumeric.html" title='nom::is_alphanumeric fn'>is_alphanumeric</a></td><td class='docblock-short'><p>Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.is_digit.html" title='nom::is_digit fn'>is_digit</a></td><td class='docblock-short'><p>Tests if byte is ASCII digit: 0-9</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.is_hex_digit.html" title='nom::is_hex_digit fn'>is_hex_digit</a></td><td class='docblock-short'><p>Tests if byte is ASCII hex digit: 0-9, A-F, a-f</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.is_oct_digit.html" title='nom::is_oct_digit fn'>is_oct_digit</a></td><td class='docblock-short'><p>Tests if byte is ASCII octal digit: 0-7</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.is_space.html" title='nom::is_space fn'>is_space</a></td><td class='docblock-short'><p>Tests if byte is ASCII space or tab</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_f32.html" title='nom::le_f32 fn'>le_f32</a></td><td class='docblock-short'><p>Recognizes little endian 4 bytes floating point number</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_f64.html" title='nom::le_f64 fn'>le_f64</a></td><td class='docblock-short'><p>Recognizes little endian 8 bytes floating point number</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_i8.html" title='nom::le_i8 fn'>le_i8</a></td><td class='docblock-short'><p>Recognizes a signed 1 byte integer (equivalent to take!(1)</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_i16.html" title='nom::le_i16 fn'>le_i16</a></td><td class='docblock-short'><p>Recognizes little endian signed 2 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_i24.html" title='nom::le_i24 fn'>le_i24</a></td><td class='docblock-short'><p>Recognizes little endian signed 3 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_i32.html" title='nom::le_i32 fn'>le_i32</a></td><td class='docblock-short'><p>Recognizes little endian signed 4 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_i64.html" title='nom::le_i64 fn'>le_i64</a></td><td class='docblock-short'><p>Recognizes little endian signed 8 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_i128.html" title='nom::le_i128 fn'>le_i128</a></td><td class='docblock-short'><p>Recognizes little endian signed 16 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_u8.html" title='nom::le_u8 fn'>le_u8</a></td><td class='docblock-short'><p>Recognizes an unsigned 1 byte integer (equivalent to take!(1)</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_u16.html" title='nom::le_u16 fn'>le_u16</a></td><td class='docblock-short'><p>Recognizes little endian unsigned 2 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_u24.html" title='nom::le_u24 fn'>le_u24</a></td><td class='docblock-short'><p>Recognizes little endian unsigned 3 byte integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_u32.html" title='nom::le_u32 fn'>le_u32</a></td><td class='docblock-short'><p>Recognizes little endian unsigned 4 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_u64.html" title='nom::le_u64 fn'>le_u64</a></td><td class='docblock-short'><p>Recognizes little endian unsigned 8 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.le_u128.html" title='nom::le_u128 fn'>le_u128</a></td><td class='docblock-short'><p>Recognizes little endian unsigned 16 bytes integer</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.line_ending.html" title='nom::line_ending fn'>line_ending</a></td><td class='docblock-short'><p>Recognizes an end of line (both '\n' and '\r\n')</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.multispace.html" title='nom::multispace fn'>multispace</a></td><td class='docblock-short'><p>Recognizes one or more spaces, tabs, carriage returns and line feeds</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.multispace0.html" title='nom::multispace0 fn'>multispace0</a></td><td class='docblock-short'><p>Recognizes zero or more spaces, tabs, carriage returns and line feeds</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.multispace1.html" title='nom::multispace1 fn'>multispace1</a></td><td class='docblock-short'><p>Recognizes one or more spaces, tabs, carriage returns and line feeds</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.need_more.html" title='nom::need_more fn'>need_more</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.need_more_err.html" title='nom::need_more_err fn'>need_more_err</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.newline.html" title='nom::newline fn'>newline</a></td><td class='docblock-short'><p>Matches a newline character '\n'</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.non_empty.html" title='nom::non_empty fn'>non_empty</a></td><td class='docblock-short'><p>Recognizes non empty buffers</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.not_line_ending.html" title='nom::not_line_ending fn'>not_line_ending</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.oct_digit.html" title='nom::oct_digit fn'>oct_digit</a></td><td class='docblock-short'><p>Recognizes one or more octal characters: 0-7</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.oct_digit0.html" title='nom::oct_digit0 fn'>oct_digit0</a></td><td class='docblock-short'><p>Recognizes zero or more octal characters: 0-7</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.oct_digit1.html" title='nom::oct_digit1 fn'>oct_digit1</a></td><td class='docblock-short'><p>Recognizes one or more octal characters: 0-7</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.print.html" title='nom::print fn'>print</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.print_codes.html" title='nom::print_codes fn'>print_codes</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.recognize_float.html" title='nom::recognize_float fn'>recognize_float</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.reset_color.html" title='nom::reset_color fn'>reset_color</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.rest.html" title='nom::rest fn'>rest</a></td><td class='docblock-short'><p>Return the remaining input.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.rest_len.html" title='nom::rest_len fn'>rest_len</a></td><td class='docblock-short'><p>Return the length of the remaining input.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.rest_s.html" title='nom::rest_s fn'>rest_s</a></td><td class='docblock-short'><p>Return the remaining input, for strings.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.sized_buffer.html" title='nom::sized_buffer fn'>sized_buffer</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.slice_to_offsets.html" title='nom::slice_to_offsets fn'>slice_to_offsets</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.space.html" title='nom::space fn'>space</a></td><td class='docblock-short'><p>Recognizes one or more spaces and tabs</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.space0.html" title='nom::space0 fn'>space0</a></td><td class='docblock-short'><p>Recognizes zero or more spaces and tabs</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.space1.html" title='nom::space1 fn'>space1</a></td><td class='docblock-short'><p>Recognizes one or more spaces and tabs</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.tab.html" title='nom::tab fn'>tab</a></td><td class='docblock-short'><p>Matches a tab character '\t'</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.tag_cl.html" title='nom::tag_cl fn'>tag_cl</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.write_color.html" title='nom::write_color fn'>write_color</a></td><td class='docblock-short'></td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.IResult.html" title='nom::IResult type'>IResult</a></td><td class='docblock-short'><p>Holds the result of parsing functions</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "nom";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>