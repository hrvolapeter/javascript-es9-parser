<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `CompleteStr` struct in crate `nom`."><meta name="keywords" content="rust, rustlang, rust-lang, CompleteStr"><title>nom::types::CompleteStr - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../nom/index.html'><img src='../../rust-logo.png' alt='logo' width='100'></a><p class='location'>Struct CompleteStr</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#deref-methods">Methods from Deref&lt;Target=&amp;&#39;a str&gt;</a><div class="sidebar-links"><a href="#method.as_bytes">as_bytes</a><a href="#method.as_ptr">as_ptr</a><a href="#method.bytes">bytes</a><a href="#method.char_indices">char_indices</a><a href="#method.chars">chars</a><a href="#method.contains">contains</a><a href="#method.encode_utf16">encode_utf16</a><a href="#method.ends_with">ends_with</a><a href="#method.eq_ignore_ascii_case">eq_ignore_ascii_case</a><a href="#method.escape_debug">escape_debug</a><a href="#method.escape_default">escape_default</a><a href="#method.escape_unicode">escape_unicode</a><a href="#method.find">find</a><a href="#method.get">get</a><a href="#method.get_unchecked">get_unchecked</a><a href="#method.is_ascii">is_ascii</a><a href="#method.is_char_boundary">is_char_boundary</a><a href="#method.is_empty">is_empty</a><a href="#method.len">len</a><a href="#method.lines">lines</a><a href="#method.lines_any">lines_any</a><a href="#method.match_indices">match_indices</a><a href="#method.matches">matches</a><a href="#method.parse">parse</a><a href="#method.repeat">repeat</a><a href="#method.replace">replace</a><a href="#method.replacen">replacen</a><a href="#method.rfind">rfind</a><a href="#method.rmatch_indices">rmatch_indices</a><a href="#method.rmatches">rmatches</a><a href="#method.rsplit">rsplit</a><a href="#method.rsplit_terminator">rsplit_terminator</a><a href="#method.rsplitn">rsplitn</a><a href="#method.slice_unchecked">slice_unchecked</a><a href="#method.split">split</a><a href="#method.split_ascii_whitespace">split_ascii_whitespace</a><a href="#method.split_at">split_at</a><a href="#method.split_terminator">split_terminator</a><a href="#method.split_whitespace">split_whitespace</a><a href="#method.splitn">splitn</a><a href="#method.starts_with">starts_with</a><a href="#method.to_ascii_lowercase">to_ascii_lowercase</a><a href="#method.to_ascii_uppercase">to_ascii_uppercase</a><a href="#method.to_lowercase">to_lowercase</a><a href="#method.to_uppercase">to_uppercase</a><a href="#method.trim">trim</a><a href="#method.trim_end">trim_end</a><a href="#method.trim_end_matches">trim_end_matches</a><a href="#method.trim_left">trim_left</a><a href="#method.trim_left_matches">trim_left_matches</a><a href="#method.trim_matches">trim_matches</a><a href="#method.trim_right">trim_right</a><a href="#method.trim_right_matches">trim_right_matches</a><a href="#method.trim_start">trim_start</a><a href="#method.trim_start_matches">trim_start_matches</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-AsBytes">AsBytes</a><a href="#impl-AsRef%3Cstr%3E">AsRef&lt;str&gt;</a><a href="#impl-AtEof">AtEof</a><a href="#impl-Clone">Clone</a><a href="#impl-Compare%3C%26%27b%20str%3E">Compare&lt;&amp;&#39;b str&gt;</a><a href="#impl-Copy">Copy</a><a href="#impl-Debug">Debug</a><a href="#impl-Deref">Deref</a><a href="#impl-Display">Display</a><a href="#impl-Eq">Eq</a><a href="#impl-ExtendInto">ExtendInto</a><a href="#impl-FindSubstring%3C%26%27b%20str%3E">FindSubstring&lt;&amp;&#39;b str&gt;</a><a href="#impl-FindToken%3C%26%27a%20u8%3E">FindToken&lt;&amp;&#39;a u8&gt;</a><a href="#impl-FindToken%3Cchar%3E">FindToken&lt;char&gt;</a><a href="#impl-FindToken%3Cu8%3E">FindToken&lt;u8&gt;</a><a href="#impl-From%3C%26%27a%20str%3E">From&lt;&amp;&#39;a str&gt;</a><a href="#impl-From%3C%26%27b%20%26%27a%20str%3E">From&lt;&amp;&#39;b &amp;&#39;a str&gt;</a><a href="#impl-Hash">Hash</a><a href="#impl-InputIter">InputIter</a><a href="#impl-InputLength">InputLength</a><a href="#impl-InputTake">InputTake</a><a href="#impl-InputTakeAtPosition">InputTakeAtPosition</a><a href="#impl-Offset">Offset</a><a href="#impl-ParseTo%3CR%3E">ParseTo&lt;R&gt;</a><a href="#impl-PartialEq%3CCompleteStr%3C%27a%3E%3E">PartialEq&lt;CompleteStr&lt;&#39;a&gt;&gt;</a><a href="#impl-Slice%3CRange%3Cusize%3E%3E">Slice&lt;Range&lt;usize&gt;&gt;</a><a href="#impl-Slice%3CRangeFrom%3Cusize%3E%3E">Slice&lt;RangeFrom&lt;usize&gt;&gt;</a><a href="#impl-Slice%3CRangeFull%3E">Slice&lt;RangeFull&gt;</a><a href="#impl-Slice%3CRangeTo%3Cusize%3E%3E">Slice&lt;RangeTo&lt;usize&gt;&gt;</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-ToString">ToString</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class='location'><a href='../index.html'>nom</a>::<wbr><a href='index.html'>types</a></p><script>window.sidebarCurrent = {name: 'CompleteStr', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/nom/types.rs.html#23' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='../index.html'>nom</a>::<wbr><a href='index.html'>types</a>::<wbr><a class="struct" href=''>CompleteStr</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'>pub struct CompleteStr&lt;'a&gt;(pub &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>);</pre></div><div class='docblock'><p>Holds a complete String, for which the <code>at_eof</code> method always returns true</p>
<p>This means that this input type will completely avoid nom's streaming features
and <code>Incomplete</code> results.</p>
</div><h2 id='deref-methods' class='small-section-header'>Methods from <a class="trait" href="../../nom/lib/std/ops/trait.Deref.html" title="trait nom::lib::std::ops::Deref">Deref</a>&lt;Target = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;<a href='#deref-methods' class='anchor'></a></h2><div class='impl-items'><h4 id='method.len' class="method"><code id='len.v'>pub const fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2060-2062' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not [<code>char</code>]s or graphemes. In other words,
it may not be what a human considers the length of the string.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="string">&quot;foo&quot;</span>.<span class="ident">len</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">3</span>, <span class="ident">len</span>);

<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="string">&quot;ƒoo&quot;</span>.<span class="ident">len</span>(); <span class="comment">// fancy f!</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">4</span>, <span class="ident">len</span>);</pre></div>
</div><h4 id='method.is_empty' class="method"><code id='is_empty.v'>pub const fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2080-2082' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_empty</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;not empty&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id='method.is_char_boundary' class="method"><code id='is_char_boundary.v'>pub fn <a href='#method.is_char_boundary' class='fnname'>is_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.9.0'>1.9.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2110-2120' title='goto source code'>[src]</a></h4><div class='docblock'><p>Checks that <code>index</code>-th byte lies at the start and/or end of a
UTF-8 code point sequence.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be
boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">0</span>));
<span class="comment">// start of `老`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">6</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="ident">s</span>.<span class="ident">len</span>()));

<span class="comment">// second byte of `ö`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">2</span>));

<span class="comment">// third byte of `老`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">8</span>));</pre></div>
</div><h4 id='method.as_bytes' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></h3><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span></code></div></div><code id='as_bytes.v'>pub const fn <a href='#method.as_bytes' class='fnname'>as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2138-2144' title='goto source code'>[src]</a></h4><div class='docblock'><p>Converts a string slice to a byte slice. To convert the byte slice back
into a string slice, use the <a href="./str/fn.from_utf8.html"><code>str::from_utf8</code></a> function.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">&quot;bors&quot;</span>.<span class="ident">as_bytes</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;bors&quot;</span>, <span class="ident">bytes</span>);</pre></div>
</div><h4 id='method.as_ptr' class="method"><code id='as_ptr.v'>pub const fn <a href='#method.as_ptr' class='fnname'>as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2203-2205' title='goto source code'>[src]</a></h4><div class='docblock'><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Hello&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();</pre></div>
</div><h4 id='method.get' class="method"><code id='get.v'>pub fn <a href='#method.get' class='fnname'>get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class="enum" href="../../nom/lib/std/prelude/v1/v1/enum.Option.html" title="enum nom::lib::std::prelude::v1::v1::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="../../nom/lib/std/slice/trait.SliceIndex.html" title="trait nom::lib::std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;::<a class="type" href="../../nom/lib/std/slice/trait.SliceIndex.html#associatedtype.Output" title="type nom::lib::std::slice::SliceIndex::Output">Output</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../nom/lib/std/slice/trait.SliceIndex.html" title="trait nom::lib::std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.20.0'>1.20.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2246-2248' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="option/enum.Option.html#variant.None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;🗻∈🌏&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;🗻&quot;</span>), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">0</span>..<span class="number">4</span>));

<span class="comment">// indices not on UTF-8 sequence boundaries</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">get</span>(<span class="number">1</span>..).<span class="ident">is_none</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">get</span>(..<span class="number">8</span>).<span class="ident">is_none</span>());

<span class="comment">// out of bounds</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">get</span>(..<span class="number">42</span>).<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.get_unchecked' class="method"><code id='get_unchecked.v'>pub unsafe fn <a href='#method.get_unchecked' class='fnname'>get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as <a class="trait" href="../../nom/lib/std/slice/trait.SliceIndex.html" title="trait nom::lib::std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;::<a class="type" href="../../nom/lib/std/slice/trait.SliceIndex.html#associatedtype.Output" title="type nom::lib::std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../nom/lib/std/slice/trait.SliceIndex.html" title="trait nom::lib::std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.20.0'>1.20.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2312-2314' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must come before the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="string">&quot;🗻∈🌏&quot;</span>;
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;🗻&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;∈&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;🌏&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">7</span>..<span class="number">11</span>));
}</pre></div>
</div><h4 id='method.slice_unchecked' class="method"><code id='slice_unchecked.v'>pub unsafe fn <a href='#method.slice_unchecked' class='fnname'>slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, end: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2394-2396' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab deprecated'>Deprecated since 1.29.0: <p>use <code>get_unchecked(begin..end)</code> instead</p>
</div></div><div class='docblock'><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="primitive.str.html"><code>str</code></a> and <a href="ops/trait.Index.html"><code>Index</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="#method.slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must come before <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Löwe 老虎 Léopard&quot;</span>, <span class="ident">s</span>.<span class="ident">slice_unchecked</span>(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Hello, world!&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;world&quot;</span>, <span class="ident">s</span>.<span class="ident">slice_unchecked</span>(<span class="number">7</span>, <span class="number">12</span>));
}</pre></div>
</div><h4 id='method.split_at' class="method"><code id='split_at.v'>pub fn <a href='#method.split_at' class='fnname'>split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a></code><span class='since' title='Stable since Rust version 1.4.0'>1.4.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2461-2471' title='goto source code'>[src]</a></h4><div class='docblock'><p>Divide one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="#method.split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is
beyond the last code point of the string slice.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Per Martin-Löf&quot;</span>;

<span class="kw">let</span> (<span class="ident">first</span>, <span class="ident">last</span>) <span class="op">=</span> <span class="ident">s</span>.<span class="ident">split_at</span>(<span class="number">3</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Per&quot;</span>, <span class="ident">first</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot; Martin-Löf&quot;</span>, <span class="ident">last</span>);</pre></div>
</div><h4 id='method.chars' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.Chars.html" title="struct nom::lib::std::str::Chars">Chars</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.Chars.html" title="struct nom::lib::std::str::Chars">Chars</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.Chars.html" title="struct nom::lib::std::str::Chars">Chars</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>;</span></code></div></div><code id='chars.v'>pub fn <a href='#method.chars' class='fnname'>chars</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.Chars.html" title="struct nom::lib::std::str::Chars">Chars</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2569-2571' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over the [<code>char</code>]s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by [<code>char</code>]. This method returns such an iterator.</p>
<p>It's important to remember that [<code>char</code>] represents a Unicode Scalar
Value, and may not match your idea of what a 'character' is. Iteration
over grapheme clusters may be what you actually want.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">chars</span>().<span class="ident">count</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">7</span>, <span class="ident">count</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">chars</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;g&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;d&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;b&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;e&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">chars</span>.<span class="ident">next</span>());</pre></div>
<p>Remember, [<code>char</code>]s may not match your human intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="string">&quot;y̆&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span> <span class="op">=</span> <span class="ident">y</span>.<span class="ident">chars</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>()); <span class="comment">// not &#39;y̆&#39;</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;\u{0306}&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">chars</span>.<span class="ident">next</span>());</pre></div>
</div><h4 id='method.char_indices' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.CharIndices.html" title="struct nom::lib::std::str::CharIndices">CharIndices</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.CharIndices.html" title="struct nom::lib::std::str::CharIndices">CharIndices</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.CharIndices.html" title="struct nom::lib::std::str::CharIndices">CharIndices</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><code id='char_indices.v'>pub fn <a href='#method.char_indices' class='fnname'>char_indices</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.CharIndices.html" title="struct nom::lib::std::str::CharIndices">CharIndices</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2624-2626' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over the [<code>char</code>]s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by [<code>char</code>]. This method returns an iterator of both
these [<code>char</code>]s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the [<code>char</code>] is
second.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">char_indices</span>().<span class="ident">count</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">7</span>, <span class="ident">count</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">char_indices</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">char_indices</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;g&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;o&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">&#39;o&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;d&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;b&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">&#39;y&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">&#39;e&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">char_indices</span>.<span class="ident">next</span>());</pre></div>
<p>Remember, [<code>char</code>]s may not match your human intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">yes</span> <span class="op">=</span> <span class="string">&quot;y̆es&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">char_indices</span> <span class="op">=</span> <span class="ident">yes</span>.<span class="ident">char_indices</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;y&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>()); <span class="comment">// not (0, &#39;y̆&#39;)</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;\u{0306}&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="comment">// note the 3 here - the last character took up two bytes</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;e&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;s&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">char_indices</span>.<span class="ident">next</span>());</pre></div>
</div><h4 id='method.bytes' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.Bytes.html" title="struct nom::lib::std::str::Bytes">Bytes</a>&lt;'_&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.Bytes.html" title="struct nom::lib::std::str::Bytes">Bytes</a>&lt;'_&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.Bytes.html" title="struct nom::lib::std::str::Bytes">Bytes</a>&lt;'_&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>;</span></code></div></div><code id='bytes.v'>pub fn <a href='#method.bytes' class='fnname'>bytes</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.Bytes.html" title="struct nom::lib::std::str::Bytes">Bytes</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2649-2651' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">&quot;bors&quot;</span>.<span class="ident">bytes</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;b&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;o&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;r&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;s&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">bytes</span>.<span class="ident">next</span>());</pre></div>
</div><h4 id='method.split_whitespace' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.SplitWhitespace.html" title="struct nom::lib::std::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.SplitWhitespace.html" title="struct nom::lib::std::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.SplitWhitespace.html" title="struct nom::lib::std::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='split_whitespace.v'>pub fn <a href='#method.split_whitespace' class='fnname'>split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.SplitWhitespace.html" title="struct nom::lib::std::str::SplitWhitespace">SplitWhitespace</a></code><span class='since' title='Stable since Rust version 1.1.0'>1.1.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2692-2694' title='goto source code'>[src]</a></h4><div class='docblock'><p>Splits a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace
instead, use <a href="#method.split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot;A few words&quot;</span>.<span class="ident">split_whitespace</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</pre></div>
<p>All kinds of whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot; Mary   had\ta\u{2009}little  \n\t lamb&quot;</span>.<span class="ident">split_whitespace</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</pre></div>
</div><h4 id='method.split_ascii_whitespace' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.SplitAsciiWhitespace.html" title="struct nom::lib::std::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.SplitAsciiWhitespace.html" title="struct nom::lib::std::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.SplitAsciiWhitespace.html" title="struct nom::lib::std::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='split_ascii_whitespace.v'>pub fn <a href='#method.split_ascii_whitespace' class='fnname'>split_ascii_whitespace</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.SplitAsciiWhitespace.html" title="struct nom::lib::std::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a></code><span class='since' title='Stable since Rust version 1.34.0'>1.34.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2733-2740' title='goto source code'>[src]</a></h4><div class='docblock'><p>Splits a string slice by ASCII whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of ASCII whitespace.</p>
<p>To split by Unicode <code>Whitespace</code> instead, use <a href="#method.split_whitespace"><code>split_whitespace</code></a>.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot;A few words&quot;</span>.<span class="ident">split_ascii_whitespace</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</pre></div>
<p>All kinds of ASCII whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot; Mary   had\ta little  \n\t lamb&quot;</span>.<span class="ident">split_ascii_whitespace</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</pre></div>
</div><h4 id='method.lines' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.Lines.html" title="struct nom::lib::std::str::Lines">Lines</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.Lines.html" title="struct nom::lib::std::str::Lines">Lines</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.Lines.html" title="struct nom::lib::std::str::Lines">Lines</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='lines.v'>pub fn <a href='#method.lines' class='fnname'>lines</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.Lines.html" title="struct nom::lib::std::str::Lines">Lines</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2780-2782' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over the lines of a string, as string slices.</p>
<p>Lines are ended with either a newline (<code>\n</code>) or a carriage return with
a line feed (<code>\r\n</code>).</p>
<p>The final line ending is optional.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo\r\nbar\n\nbaz\n&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lines</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">lines</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">lines</span>.<span class="ident">next</span>());</pre></div>
<p>The final line ending isn't required:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo\nbar\n\r\nbaz&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lines</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">lines</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">lines</span>.<span class="ident">next</span>());</pre></div>
</div><h4 id='method.lines_any' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.LinesAny.html" title="struct nom::lib::std::str::LinesAny">LinesAny</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.LinesAny.html" title="struct nom::lib::std::str::LinesAny">LinesAny</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.LinesAny.html" title="struct nom::lib::std::str::LinesAny">LinesAny</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='lines_any.v'>pub fn <a href='#method.lines_any' class='fnname'>lines_any</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.LinesAny.html" title="struct nom::lib::std::str::LinesAny">LinesAny</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2789-2791' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab deprecated'>Deprecated since 1.4.0: <p>use lines() instead now</p>
</div></div><div class='docblock'><p>An iterator over the lines of a string.</p>
</div><h4 id='method.encode_utf16' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.EncodeUtf16.html" title="struct nom::lib::std::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.EncodeUtf16.html" title="struct nom::lib::std::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.EncodeUtf16.html" title="struct nom::lib::std::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a>;</span></code></div></div><code id='encode_utf16.v'>pub fn <a href='#method.encode_utf16' class='fnname'>encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.EncodeUtf16.html" title="struct nom::lib::std::str::EncodeUtf16">EncodeUtf16</a></code><span class='since' title='Stable since Rust version 1.8.0'>1.8.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2808-2810' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;Zażółć gęślą jaźń&quot;</span>;

<span class="kw">let</span> <span class="ident">utf8_len</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">len</span>();
<span class="kw">let</span> <span class="ident">utf16_len</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">encode_utf16</span>().<span class="ident">count</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">utf16_len</span> <span class="op">&lt;=</span> <span class="ident">utf8_len</span>);</pre></div>
</div><h4 id='method.contains' class="method"><code id='contains.v'>pub fn <a href='#method.contains' class='fnname'>contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2829-2831' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bananas</span>.<span class="ident">contains</span>(<span class="string">&quot;nana&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">contains</span>(<span class="string">&quot;apples&quot;</span>));</pre></div>
</div><h4 id='method.starts_with' class="method"><code id='starts_with.v'>pub fn <a href='#method.starts_with' class='fnname'>starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2849-2851' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bananas</span>.<span class="ident">starts_with</span>(<span class="string">&quot;bana&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">starts_with</span>(<span class="string">&quot;nana&quot;</span>));</pre></div>
</div><h4 id='method.ends_with' class="method"><code id='ends_with.v'>pub fn <a href='#method.ends_with' class='fnname'>ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2869-2873' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bananas</span>.<span class="ident">ends_with</span>(<span class="string">&quot;anas&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">ends_with</span>(<span class="string">&quot;nana&quot;</span>));</pre></div>
</div><h4 id='method.find' class="method"><code id='find.v'>pub fn <a href='#method.find' class='fnname'>find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="../../nom/lib/std/prelude/v1/v1/enum.Option.html" title="enum nom::lib::std::prelude::v1::v1::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2918-2920' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="option/enum.Option.html#variant.None"><code>None</code></a> if the pattern doesn't match.</p>
<p>The pattern can be a <code>&amp;str</code>, [<code>char</code>], or a closure that determines if
a character matches.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&#39;é&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&quot;Léopard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));</pre></div>
<p>More complex patterns using point-free style and closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">char</span>::<span class="ident">is_whitespace</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">char</span>::<span class="ident">is_lowercase</span>), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="op">|</span><span class="ident">c</span>: <span class="ident">char</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_whitespace</span>() <span class="op">||</span> <span class="ident">c</span>.<span class="ident">is_lowercase</span>()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="op">|</span><span class="ident">c</span>: <span class="ident">char</span><span class="op">|</span> (<span class="ident">c</span> <span class="op">&lt;</span> <span class="string">&#39;o&#39;</span>) <span class="op">&amp;&amp;</span> (<span class="ident">c</span> <span class="op">&gt;</span> <span class="string">&#39;a&#39;</span>)), <span class="prelude-val">Some</span>(<span class="number">4</span>));</pre></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">x</span>), <span class="prelude-val">None</span>);</pre></div>
</div><h4 id='method.rfind' class="method"><code id='rfind.v'>pub fn <a href='#method.rfind' class='fnname'>rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="../../nom/lib/std/prelude/v1/v1/enum.Option.html" title="enum nom::lib::std::prelude::v1::v1::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2962-2966' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the byte index of the last character of this string slice that
matches the pattern.</p>
<p>Returns <a href="option/enum.Option.html#variant.None"><code>None</code></a> if the pattern doesn't match.</p>
<p>The pattern can be a <code>&amp;str</code>, [<code>char</code>], or a closure that determines if
a character matches.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&#39;é&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));</pre></div>
<p>More complex patterns with closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">char</span>::<span class="ident">is_whitespace</span>), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">char</span>::<span class="ident">is_lowercase</span>), <span class="prelude-val">Some</span>(<span class="number">20</span>));</pre></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">x</span>), <span class="prelude-val">None</span>);</pre></div>
</div><h4 id='method.split' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.Split.html" title="struct nom::lib::std::str::Split">Split</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.Split.html" title="struct nom::lib::std::str::Split">Split</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.Split.html" title="struct nom::lib::std::str::Split">Split</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='split.v'>pub fn <a href='#method.split' class='fnname'>split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.Split.html" title="struct nom::lib::std::str::Split">Split</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3075-3083' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The pattern can be any type that implements the Pattern trait. Notable
examples are <code>&amp;str</code>, [<code>char</code>], and closures that determines the split.</p>
<h1 id="iterator-behavior" class="section-header"><a href="#iterator-behavior">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., [<code>char</code>], but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rsplit"><code>rsplit</code></a> method can be used.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;lamb&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">split</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">split</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1def2ghi&quot;</span>.<span class="ident">split</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXtigerXleopard&quot;</span>.<span class="ident">split</span>(<span class="ident">char</span>::<span class="ident">is_uppercase</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);</pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);</pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;||||a||b|c&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39;|&#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</pre></div>
<p>Contiguous separators are separated by the empty string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;(///)&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39;/&#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;(&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;)&quot;</span>]);</pre></div>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;010&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;0&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;&quot;</span>]);</pre></div>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;rust&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;&quot;</span>]);</pre></div>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;    a  b c&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</pre></div>
<p>It does <em>not</em> give you:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</pre></div>
<p>Use <a href="#method.split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div><h4 id='method.rsplit' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.RSplit.html" title="struct nom::lib::std::str::RSplit">RSplit</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.RSplit.html" title="struct nom::lib::std::str::RSplit">RSplit</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.RSplit.html" title="struct nom::lib::std::str::RSplit">RSplit</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='rsplit.v'>pub fn <a href='#method.rsplit' class='fnname'>rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.RSplit.html" title="struct nom::lib::std::str::RSplit">RSplit</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3129-3133' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern and yielded in reverse order.</p>
<p>The pattern can be any type that implements the Pattern trait. Notable
examples are <code>&amp;str</code>, [<code>char</code>], and closures that determines the split.</p>
<h1 id="iterator-behavior-1" class="section-header"><a href="#iterator-behavior-1">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.split"><code>split</code></a> method can be used.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;Mary&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;lion&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lion&quot;</span>]);</pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;abc&quot;</span>]);</pre></div>
</div><h4 id='method.split_terminator' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.SplitTerminator.html" title="struct nom::lib::std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.SplitTerminator.html" title="struct nom::lib::std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.SplitTerminator.html" title="struct nom::lib::std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='split_terminator.v'>pub fn <a href='#method.split_terminator' class='fnname'>split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.SplitTerminator.html" title="struct nom::lib::std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3175-3180' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern.</p>
<p>The pattern can be any type that implements the Pattern trait. Notable
examples are <code>&amp;str</code>, [<code>char</code>], and closures that determines the split.</p>
<p>Equivalent to <a href="#method.split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h1 id="iterator-behavior-2" class="section-header"><a href="#iterator-behavior-2">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., [<code>char</code>], but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B.&quot;</span>.<span class="ident">split_terminator</span>(<span class="string">&#39;.&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A..B..&quot;</span>.<span class="ident">split_terminator</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>]);</pre></div>
</div><h4 id='method.rsplit_terminator' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.RSplitTerminator.html" title="struct nom::lib::std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.RSplitTerminator.html" title="struct nom::lib::std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.RSplitTerminator.html" title="struct nom::lib::std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='rsplit_terminator.v'>pub fn <a href='#method.rsplit_terminator' class='fnname'>rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.RSplitTerminator.html" title="struct nom::lib::std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3220-3224' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The pattern can be any type that implements the Pattern trait. Notable
examples are <code>&amp;str</code>, [<code>char</code>], and closures that determines the split.
Additional libraries might provide more complex patterns like
regular expressions.</p>
<p>Equivalent to <a href="#method.split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h1 id="iterator-behavior-3" class="section-header"><a href="#iterator-behavior-3">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B.&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="string">&#39;.&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A..B..&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A&quot;</span>]);</pre></div>
</div><h4 id='method.splitn' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.SplitN.html" title="struct nom::lib::std::str::SplitN">SplitN</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.SplitN.html" title="struct nom::lib::std::str::SplitN">SplitN</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.SplitN.html" title="struct nom::lib::std::str::SplitN">SplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='splitn.v'>pub fn <a href='#method.splitn' class='fnname'>splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.SplitN.html" title="struct nom::lib::std::str::SplitN">SplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3271-3276' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over substrings of the given string slice, separated by a
pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The pattern can be any type that implements the Pattern trait. Notable
examples are <code>&amp;str</code>, [<code>char</code>], and closures that determines the split.</p>
<h1 id="iterator-behavior-4" class="section-header"><a href="#iterator-behavior-4">Iterator behavior</a></h1>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="#method.rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lambda&quot;</span>.<span class="ident">splitn</span>(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a little lambda&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">splitn</span>(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tigerXleopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXdef&quot;</span>.<span class="ident">splitn</span>(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abcXdef&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">splitn</span>(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);</pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;defXghi&quot;</span>]);</pre></div>
</div><h4 id='method.rsplitn' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.RSplitN.html" title="struct nom::lib::std::str::RSplitN">RSplitN</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.RSplitN.html" title="struct nom::lib::std::str::RSplitN">RSplitN</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.RSplitN.html" title="struct nom::lib::std::str::RSplitN">RSplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='rsplitn.v'>pub fn <a href='#method.rsplitn' class='fnname'>rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.RSplitN.html" title="struct nom::lib::std::str::RSplitN">RSplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3320-3324' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning
at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The pattern can be any type that implements the Pattern trait. Notable
examples are <code>&amp;str</code>, [<code>char</code>], and closures that determines the split.</p>
<h1 id="iterator-behavior-5" class="section-header"><a href="#iterator-behavior-5">Iterator behavior</a></h1>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="#method.splitn"><code>splitn</code></a> method can be used.</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;Mary had a&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">3</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lionX&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;lion::tiger&quot;</span>]);</pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;abc1def&quot;</span>]);</pre></div>
</div><h4 id='method.matches' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.Matches.html" title="struct nom::lib::std::str::Matches">Matches</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.Matches.html" title="struct nom::lib::std::str::Matches">Matches</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.Matches.html" title="struct nom::lib::std::str::Matches">Matches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='matches.v'>pub fn <a href='#method.matches' class='fnname'>matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.Matches.html" title="struct nom::lib::std::str::Matches">Matches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.2.0'>1.2.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3358-3360' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over the disjoint matches of a pattern within the given string
slice.</p>
<p>The pattern can be any type that implements the Pattern trait. Notable
examples are <code>&amp;str</code>, [<code>char</code>], and closures that determines the split.</p>
<h1 id="iterator-behavior-6" class="section-header"><a href="#iterator-behavior-6">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., [<code>char</code>], but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rmatches"><code>rmatches</code></a> method can be used.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">matches</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abc2abc3&quot;</span>.<span class="ident">matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]);</pre></div>
</div><h4 id='method.rmatches' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.RMatches.html" title="struct nom::lib::std::str::RMatches">RMatches</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.RMatches.html" title="struct nom::lib::std::str::RMatches">RMatches</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.RMatches.html" title="struct nom::lib::std::str::RMatches">RMatches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>;</span></code></div></div><code id='rmatches.v'>pub fn <a href='#method.rmatches' class='fnname'>rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.RMatches.html" title="struct nom::lib::std::str::RMatches">RMatches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.2.0'>1.2.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3393-3397' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over the disjoint matches of a pattern within this string slice,
yielded in reverse order.</p>
<p>The pattern can be a <code>&amp;str</code>, [<code>char</code>], or a closure that determines if
a character matches.</p>
<h1 id="iterator-behavior-7" class="section-header"><a href="#iterator-behavior-7">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.matches"><code>matches</code></a> method can be used.</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">rmatches</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abc2abc3&quot;</span>.<span class="ident">rmatches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>]);</pre></div>
</div><h4 id='method.match_indices' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.MatchIndices.html" title="struct nom::lib::std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.MatchIndices.html" title="struct nom::lib::std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.MatchIndices.html" title="struct nom::lib::std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><code id='match_indices.v'>pub fn <a href='#method.match_indices' class='fnname'>match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.MatchIndices.html" title="struct nom::lib::std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.5.0'>1.5.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3437-3439' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The pattern can be a <code>&amp;str</code>, [<code>char</code>], or a closure that determines
if a character matches.</p>
<h1 id="iterator-behavior-8" class="section-header"><a href="#iterator-behavior-8">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., [<code>char</code>], but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abcabc2&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;ababa&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;aba&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">0</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the first `aba`</span></pre></div>
</div><h4 id='method.rmatch_indices' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.RMatchIndices.html" title="struct nom::lib::std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.RMatchIndices.html" title="struct nom::lib::std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.RMatchIndices.html" title="struct nom::lib::std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><code id='rmatch_indices.v'>pub fn <a href='#method.rmatch_indices' class='fnname'>rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.RMatchIndices.html" title="struct nom::lib::std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.5.0'>1.5.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3478-3482' title='goto source code'>[src]</a></h4><div class='docblock'><p>An iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The pattern can be a <code>&amp;str</code>, [<code>char</code>], or a closure that determines if a
character matches.</p>
<h1 id="iterator-behavior-9" class="section-header"><a href="#iterator-behavior-9">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.match_indices"><code>match_indices</code></a> method can be used.</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abcabc2&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;ababa&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;aba&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">2</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the last `aba`</span></pre></div>
</div><h4 id='method.trim' class="method"><code id='trim.v'><div class="docblock attributes">#[must_use = "this returns the trimmed string as a slice, without modifying the original"]
</div>pub fn <a href='#method.trim' class='fnname'>trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3501-3503' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim</span>());</pre></div>
</div><h4 id='method.trim_start' class="method"><code id='trim_start.v'><div class="docblock attributes">#[must_use = "this returns the trimmed string as a new slice, without modifying the original"]
</div>pub fn <a href='#method.trim_start' class='fnname'>trim_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><span class='since' title='Stable since Rust version 1.30.0'>1.30.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3538-3540' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a string slice with leading whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="text-directionality" class="section-header"><a href="#text-directionality">Text directionality</a></h1>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
like Arabic or Hebrew, this will be the right side.</p>
<h1 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Hello\tworld\t&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_start</span>());</pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English  &quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_start</span>().<span class="ident">chars</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  עברית  &quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;ע&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_start</span>().<span class="ident">chars</span>().<span class="ident">next</span>());</pre></div>
</div><h4 id='method.trim_end' class="method"><code id='trim_end.v'><div class="docblock attributes">#[must_use = "this returns the trimmed string as a new slice, without modifying the original"]
</div>pub fn <a href='#method.trim_end' class='fnname'>trim_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><span class='since' title='Stable since Rust version 1.30.0'>1.30.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3575-3577' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a string slice with trailing whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="text-directionality-1" class="section-header"><a href="#text-directionality-1">Text directionality</a></h1>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
like Arabic or Hebrew, this will be the left side.</p>
<h1 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot; Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_end</span>());</pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English  &quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_end</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  עברית  &quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;ת&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_end</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());</pre></div>
</div><h4 id='method.trim_left' class="method"><code id='trim_left.v'>pub fn <a href='#method.trim_left' class='fnname'>trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3616-3618' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab deprecated'>Deprecated since 1.33.0: <p>superseded by <code>trim_start</code></p>
</div></div><div class='docblock'><p>Returns a string slice with leading whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="text-directionality-2" class="section-header"><a href="#text-directionality-2">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Left' in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>right</em> side, not the left.</p>
<h1 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Hello\tworld\t&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_left</span>());</pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_left</span>().<span class="ident">chars</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  עברית&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;ע&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_left</span>().<span class="ident">chars</span>().<span class="ident">next</span>());</pre></div>
</div><h4 id='method.trim_right' class="method"><code id='trim_right.v'>pub fn <a href='#method.trim_right' class='fnname'>trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3657-3659' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab deprecated'>Deprecated since 1.33.0: <p>superseded by <code>trim_end</code></p>
</div></div><div class='docblock'><p>Returns a string slice with trailing whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="text-directionality-3" class="section-header"><a href="#text-directionality-3">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Right' in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>left</em> side, not the right.</p>
<h1 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot; Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_right</span>());</pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;English  &quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_right</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;עברית  &quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;ת&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_right</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());</pre></div>
</div><h4 id='method.trim_matches' class="method"><code id='trim_matches.v'><div class="docblock attributes">#[must_use = "this returns the trimmed string as a new slice, without modifying the original"]
</div>pub fn <a href='#method.trim_matches' class='fnname'>trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.DoubleEndedSearcher.html" title="trait nom::lib::std::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3687-3705' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The pattern can be a [<code>char</code>] or a closure that determines if a
character matches.</p>
<h1 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h1>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar&quot;</span>);</pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;1foo1barXX&quot;</span>.<span class="ident">trim_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);</pre></div>
</div><h4 id='method.trim_start_matches' class="method"><code id='trim_start_matches.v'><div class="docblock attributes">#[must_use = "this returns the trimmed string as a new slice, without modifying the original"]
</div>pub fn <a href='#method.trim_start_matches' class='fnname'>trim_start_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.30.0'>1.30.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3734-3744' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The pattern can be a <code>&amp;str</code>, [<code>char</code>], or a closure that determines if
a character matches.</p>
<h1 id="text-directionality-4" class="section-header"><a href="#text-directionality-4">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Left' in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>right</em> side, not the left.</p>
<h1 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_start_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_start_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_start_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar12&quot;</span>);</pre></div>
</div><h4 id='method.trim_end_matches' class="method"><code id='trim_end_matches.v'><div class="docblock attributes">#[must_use = "this returns the trimmed string as a new slice, without modifying the original"]
</div>pub fn <a href='#method.trim_end_matches' class='fnname'>trim_end_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.30.0'>1.30.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3779-3791' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The pattern can be a <code>&amp;str</code>, [<code>char</code>], or a closure that
determines if a character matches.</p>
<h1 id="text-directionality-5" class="section-header"><a href="#text-directionality-5">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Right' in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>left</em> side, not the right.</p>
<h1 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h1>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="ident">x</span>), <span class="string">&quot;12foo1bar&quot;</span>);</pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;1fooX&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</pre></div>
</div><h4 id='method.trim_left_matches' class="method"><code id='trim_left_matches.v'>pub fn <a href='#method.trim_left_matches' class='fnname'>trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3825-3827' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab deprecated'>Deprecated since 1.33.0: <p>superseded by <code>trim_start_matches</code></p>
</div></div><div class='docblock'><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if
a character matches.</p>
<h1 id="text-directionality-6" class="section-header"><a href="#text-directionality-6">Text directionality</a></h1>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
like Arabic or Hebrew, this will be the right side.</p>
<h1 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar12&quot;</span>);</pre></div>
</div><h4 id='method.trim_right_matches' class="method"><code id='trim_right_matches.v'>pub fn <a href='#method.trim_right_matches' class='fnname'>trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="type" href="../../nom/lib/std/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type nom::lib::std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="../../nom/lib/std/str/pattern/trait.ReverseSearcher.html" title="trait nom::lib::std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3867-3871' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab deprecated'>Deprecated since 1.33.0: <p>superseded by <code>trim_end_matches</code></p>
</div></div><div class='docblock'><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that
determines if a character matches.</p>
<h1 id="text-directionality-7" class="section-header"><a href="#text-directionality-7">Text directionality</a></h1>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
like Arabic or Hebrew, this will be the left side.</p>
<h1 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h1>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="ident">x</span>), <span class="string">&quot;12foo1bar&quot;</span>);</pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;1fooX&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</pre></div>
</div><h4 id='method.parse' class="method"><code id='parse.v'>pub fn <a href='#method.parse' class='fnname'>parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="../../nom/lib/std/prelude/v1/v1/enum.Result.html" title="enum nom::lib::std::prelude::v1::v1::Result">Result</a>&lt;F, &lt;F as <a class="trait" href="../../nom/lib/std/str/trait.FromStr.html" title="trait nom::lib::std::str::FromStr">FromStr</a>&gt;::<a class="type" href="../../nom/lib/std/str/trait.FromStr.html#associatedtype.Err" title="type nom::lib::std::str::FromStr::Err">Err</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../../nom/lib/std/str/trait.FromStr.html" title="trait nom::lib::std::str::FromStr">FromStr</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3919-3921' title='goto source code'>[src]</a></h4><div class='docblock'><p>Parses this string slice into another type.</p>
<p>Because <code>parse</code> is so general, it can cause problems with type
inference. As such, <code>parse</code> is one of the few times you'll see
the syntax affectionately known as the 'turbofish': <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
you're trying to parse into.</p>
<p><code>parse</code> can parse any type that implements the <a href="str/trait.FromStr.html"><code>FromStr</code></a> trait.</p>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p>Will return <a href="str/trait.FromStr.html#associatedtype.Err"><code>Err</code></a> if it's not possible to parse this string slice into
the desired type.</p>
<h1 id="examples-41" class="section-header"><a href="#examples-41">Examples</a></h1>
<p>Basic usage</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">four</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="string">&quot;4&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">4</span>, <span class="ident">four</span>);</pre></div>
<p>Using the 'turbofish' instead of annotating <code>four</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="string">&quot;4&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="ident">four</span>);</pre></div>
<p>Failing to parse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">nope</span> <span class="op">=</span> <span class="string">&quot;j&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">nope</span>.<span class="ident">is_err</span>());</pre></div>
</div><h4 id='method.is_ascii' class="method"><code id='is_ascii.v'>pub fn <a href='#method.is_ascii' class='fnname'>is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.23.0'>1.23.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3936-3941' title='goto source code'>[src]</a></h4><div class='docblock'><p>Checks if all characters in this string are within the ASCII range.</p>
<h1 id="examples-42" class="section-header"><a href="#examples-42">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ascii</span> <span class="op">=</span> <span class="string">&quot;hello!\n&quot;</span>;
<span class="kw">let</span> <span class="ident">non_ascii</span> <span class="op">=</span> <span class="string">&quot;Grüße, Jürgen ❤&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">ascii</span>.<span class="ident">is_ascii</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">non_ascii</span>.<span class="ident">is_ascii</span>());</pre></div>
</div><h4 id='method.eq_ignore_ascii_case' class="method"><code id='eq_ignore_ascii_case.v'>pub fn <a href='#method.eq_ignore_ascii_case' class='fnname'>eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.23.0'>1.23.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3957-3959' title='goto source code'>[src]</a></h4><div class='docblock'><p>Checks that two strings are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
<h1 id="examples-43" class="section-header"><a href="#examples-43">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert</span><span class="macro">!</span>(<span class="string">&quot;Ferris&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERRIS&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="string">&quot;Ferrös&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERRöS&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="string">&quot;Ferrös&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERRÖS&quot;</span>));</pre></div>
</div><h4 id='method.escape_debug' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.EscapeDebug.html" title="struct nom::lib::std::str::EscapeDebug">EscapeDebug</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.EscapeDebug.html" title="struct nom::lib::std::str::EscapeDebug">EscapeDebug</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.EscapeDebug.html" title="struct nom::lib::std::str::EscapeDebug">EscapeDebug</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>;</span></code></div></div><code id='escape_debug.v'>pub fn <a href='#method.escape_debug' class='fnname'>escape_debug</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.EscapeDebug.html" title="struct nom::lib::std::str::EscapeDebug">EscapeDebug</a></code><span class='since' title='Stable since Rust version 1.34.0'>1.34.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#4028-4037' title='goto source code'>[src]</a></h4><div class='docblock'><p>Return an iterator that escapes each char in <code>self</code> with <a href="../std/primitive.char.html#method.escape_debug"><code>char::escape_debug</code></a>.</p>
<p>Note: only extended grapheme codepoints that begin the string will be
escaped.</p>
<h1 id="examples-44" class="section-header"><a href="#examples-44">Examples</a></h1>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="string">&quot;❤\n!&quot;</span>.<span class="ident">escape_debug</span>() {
    <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">c</span>);
}
<span class="macro">println</span><span class="macro">!</span>();</pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;❤\n!&quot;</span>.<span class="ident">escape_debug</span>());</pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;❤\\n!&quot;</span>);</pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;❤\n!&quot;</span>.<span class="ident">escape_debug</span>().<span class="ident">to_string</span>(), <span class="string">&quot;❤\\n!&quot;</span>);</pre></div>
</div><h4 id='method.escape_default' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.EscapeDefault.html" title="struct nom::lib::std::str::EscapeDefault">EscapeDefault</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.EscapeDefault.html" title="struct nom::lib::std::str::EscapeDefault">EscapeDefault</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.EscapeDefault.html" title="struct nom::lib::std::str::EscapeDefault">EscapeDefault</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>;</span></code></div></div><code id='escape_default.v'>pub fn <a href='#method.escape_default' class='fnname'>escape_default</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.EscapeDefault.html" title="struct nom::lib::std::str::EscapeDefault">EscapeDefault</a></code><span class='since' title='Stable since Rust version 1.34.0'>1.34.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#4073-4075' title='goto source code'>[src]</a></h4><div class='docblock'><p>Return an iterator that escapes each char in <code>self</code> with <a href="../std/primitive.char.html#method.escape_default"><code>char::escape_default</code></a>.</p>
<h1 id="examples-45" class="section-header"><a href="#examples-45">Examples</a></h1>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="string">&quot;❤\n!&quot;</span>.<span class="ident">escape_default</span>() {
    <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">c</span>);
}
<span class="macro">println</span><span class="macro">!</span>();</pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;❤\n!&quot;</span>.<span class="ident">escape_default</span>());</pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;\\u{{2764}}\\n!&quot;</span>);</pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;❤\n!&quot;</span>.<span class="ident">escape_default</span>().<span class="ident">to_string</span>(), <span class="string">&quot;\\u{2764}\\n!&quot;</span>);</pre></div>
</div><h4 id='method.escape_unicode' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../nom/lib/std/str/struct.EscapeUnicode.html" title="struct nom::lib::std::str::EscapeUnicode">EscapeUnicode</a>&lt;'a&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../nom/lib/std/str/struct.EscapeUnicode.html" title="struct nom::lib::std::str::EscapeUnicode">EscapeUnicode</a>&lt;'a&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="struct" href="../../nom/lib/std/str/struct.EscapeUnicode.html" title="struct nom::lib::std::str::EscapeUnicode">EscapeUnicode</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>;</span></code></div></div><code id='escape_unicode.v'>pub fn <a href='#method.escape_unicode' class='fnname'>escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/str/struct.EscapeUnicode.html" title="struct nom::lib::std::str::EscapeUnicode">EscapeUnicode</a></code><span class='since' title='Stable since Rust version 1.34.0'>1.34.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#4111-4113' title='goto source code'>[src]</a></h4><div class='docblock'><p>Return an iterator that escapes each char in <code>self</code> with <a href="../std/primitive.char.html#method.escape_unicode"><code>char::escape_unicode</code></a>.</p>
<h1 id="examples-46" class="section-header"><a href="#examples-46">Examples</a></h1>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="string">&quot;❤\n!&quot;</span>.<span class="ident">escape_unicode</span>() {
    <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">c</span>);
}
<span class="macro">println</span><span class="macro">!</span>();</pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;❤\n!&quot;</span>.<span class="ident">escape_unicode</span>());</pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;\\u{{2764}}\\u{{a}}\\u{{21}}&quot;</span>);</pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;❤\n!&quot;</span>.<span class="ident">escape_unicode</span>().<span class="ident">to_string</span>(), <span class="string">&quot;\\u{2764}\\u{a}\\u{21}&quot;</span>);</pre></div>
</div></div><div class='impl-items'><h4 id='method.replace' class="method"><code id='replace.v'><div class="docblock attributes">#[must_use = "this returns the replaced string as a new allocation, without modifying the original"]
</div>pub fn <a href='#method.replace' class='fnname'>replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#266-276' title='goto source code'>[src]</a></h4><div class='docblock'><p>Replaces all matches of a pattern with another string.</p>
<p><code>replace</code> creates a new <a href="string/struct.String.html"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice.</p>
<h1 id="examples-47" class="section-header"><a href="#examples-47">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;this is new&quot;</span>, <span class="ident">s</span>.<span class="ident">replace</span>(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>));</pre></div>
<p>When the pattern doesn't match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">s</span>.<span class="ident">replace</span>(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>));</pre></div>
</div><h4 id='method.replacen' class="method"><code id='replacen.v'><div class="docblock attributes">#[must_use = "this returns the replaced string as a new allocation, without modifying the original"]
</div>pub fn <a href='#method.replacen' class='fnname'>replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/str/pattern/trait.Pattern.html" title="trait nom::lib::std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.16.0'>1.16.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#306-317' title='goto source code'>[src]</a></h4><div class='docblock'><p>Replaces first N matches of a pattern with another string.</p>
<p><code>replacen</code> creates a new <a href="string/struct.String.html"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice at most <code>count</code> times.</p>
<h1 id="examples-48" class="section-header"><a href="#examples-48">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;foo foo 123 foo&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;new new 123 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;new&quot;</span>, <span class="number">2</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;faa fao 123 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&#39;o&#39;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;foo foo new23 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>, <span class="string">&quot;new&quot;</span>, <span class="number">1</span>));</pre></div>
<p>When the pattern doesn't match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>, <span class="number">10</span>));</pre></div>
</div><h4 id='method.to_lowercase' class="method"><code id='to_lowercase.v'>pub fn <a href='#method.to_lowercase' class='fnname'>to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a></code><span class='since' title='Stable since Rust version 1.2.0'>1.2.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#361-404' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the lowercase equivalent of this string slice, as a new <a href="string/struct.String.html"><code>String</code></a>.</p>
<p>'Lowercase' is defined according to the terms of the Unicode Derived Core Property
<code>Lowercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="string/struct.String.html"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h1 id="examples-49" class="section-header"><a href="#examples-49">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;HELLO&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;hello&quot;</span>, <span class="ident">s</span>.<span class="ident">to_lowercase</span>());</pre></div>
<p>A tricky example, with sigma:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">sigma</span> <span class="op">=</span> <span class="string">&quot;Σ&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;σ&quot;</span>, <span class="ident">sigma</span>.<span class="ident">to_lowercase</span>());

<span class="comment">// but at the end of a word, it&#39;s ς, not σ:</span>
<span class="kw">let</span> <span class="ident">odysseus</span> <span class="op">=</span> <span class="string">&quot;ὈΔΥΣΣΕΎΣ&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;ὀδυσσεύς&quot;</span>, <span class="ident">odysseus</span>.<span class="ident">to_lowercase</span>());</pre></div>
<p>Languages without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">new_year</span> <span class="op">=</span> <span class="string">&quot;农历新年&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">new_year</span>, <span class="ident">new_year</span>.<span class="ident">to_lowercase</span>());</pre></div>
</div><h4 id='method.to_uppercase' class="method"><code id='to_uppercase.v'>pub fn <a href='#method.to_uppercase' class='fnname'>to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a></code><span class='since' title='Stable since Rust version 1.2.0'>1.2.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#435-452' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the uppercase equivalent of this string slice, as a new <a href="string/struct.String.html"><code>String</code></a>.</p>
<p>'Uppercase' is defined according to the terms of the Unicode Derived Core Property
<code>Uppercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="string/struct.String.html"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h1 id="examples-50" class="section-header"><a href="#examples-50">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;hello&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;HELLO&quot;</span>, <span class="ident">s</span>.<span class="ident">to_uppercase</span>());</pre></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">new_year</span> <span class="op">=</span> <span class="string">&quot;农历新年&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">new_year</span>, <span class="ident">new_year</span>.<span class="ident">to_uppercase</span>());</pre></div>
</div><h4 id='method.repeat' class="method"><code id='repeat.v'>pub fn <a href='#method.repeat' class='fnname'>repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a></code><span class='since' title='Stable since Rust version 1.16.0'>1.16.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#501-503' title='goto source code'>[src]</a></h4><div class='docblock'><p>Creates a new <a href="string/struct.String.html"><code>String</code></a> by repeating a string <code>n</code> times.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>This function will panic if the capacity would overflow.</p>
<h1 id="examples-51" class="section-header"><a href="#examples-51">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;abc&quot;</span>.<span class="ident">repeat</span>(<span class="number">4</span>), <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;abcabcabcabc&quot;</span>));</pre></div>
<p>A panic upon overflow:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// this will panic at runtime</span>
    <span class="string">&quot;0123456789abcdef&quot;</span>.<span class="ident">repeat</span>(<span class="ident">usize</span>::<span class="ident">max_value</span>());
}</pre></div>
</div><h4 id='method.to_ascii_uppercase' class="method"><code id='to_ascii_uppercase.v'>pub fn <a href='#method.to_ascii_uppercase' class='fnname'>to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a></code><span class='since' title='Stable since Rust version 1.23.0'>1.23.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#528-533' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a copy of this string where each character is mapped to its
ASCII upper case equivalent.</p>
<p>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',
but non-ASCII letters are unchanged.</p>
<p>To uppercase the value in-place, use <a href="#method.make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p>
<p>To uppercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p>
<h1 id="examples-52" class="section-header"><a href="#examples-52">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Grüße, Jürgen ❤&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;GRüßE, JüRGEN ❤&quot;</span>, <span class="ident">s</span>.<span class="ident">to_ascii_uppercase</span>());</pre></div>
</div><h4 id='method.to_ascii_lowercase' class="method"><code id='to_ascii_lowercase.v'>pub fn <a href='#method.to_ascii_lowercase' class='fnname'>to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a></code><span class='since' title='Stable since Rust version 1.23.0'>1.23.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#558-563' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a copy of this string where each character is mapped to its
ASCII lower case equivalent.</p>
<p>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',
but non-ASCII letters are unchanged.</p>
<p>To lowercase the value in-place, use <a href="#method.make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p>
<p>To lowercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p>
<h1 id="examples-53" class="section-header"><a href="#examples-53">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Grüße, Jürgen ❤&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;grüße, jürgen ❤&quot;</span>, <span class="ident">s</span>.<span class="ident">to_ascii_lowercase</span>());</pre></div>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-InputLength' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.InputLength.html" title="trait nom::InputLength">InputLength</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-InputLength' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#127-131' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.input_len' class="method hidden"><code id='input_len.v'>fn <a href='../../nom/trait.InputLength.html#tymethod.input_len' class='fnname'>input_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class='srclink' href='../../src/nom/types.rs.html#128-130' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>calculates the input length, as indicated by its name, and the name of the trait itself <a href="../../nom/trait.InputLength.html#tymethod.input_len">Read more</a></p>
</div></div><h3 id='impl-Offset' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.Offset.html" title="trait nom::Offset">Offset</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Offset' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#172-176' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.offset' class="method hidden"><code id='offset.v'>fn <a href='../../nom/trait.Offset.html#tymethod.offset' class='fnname'>offset</a>(&amp;self, second: &amp;<a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class='srclink' href='../../src/nom/types.rs.html#173-175' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>offset between the first byte of self and the first byte of the argument</p>
</div></div><h3 id='impl-AsBytes' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.AsBytes.html" title="trait nom::AsBytes">AsBytes</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-AsBytes' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#178-182' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.as_bytes-1' class="method hidden"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></h3><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span></code></div></div><code id='as_bytes.v-1'>fn <a href='../../nom/trait.AsBytes.html#tymethod.as_bytes' class='fnname'>as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code><a class='srclink' href='../../src/nom/types.rs.html#179-181' title='goto source code'>[src]</a></h4></div><h3 id='impl-InputIter' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.InputIter.html" title="trait nom::InputIter">InputIter</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-InputIter' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#93-114' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Item' class="type"><code id='Item.t'>type <a href='../../nom/trait.InputIter.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a></code></h4><h4 id='associatedtype.RawItem' class="type"><code id='RawItem.t'>type <a href='../../nom/trait.InputIter.html#associatedtype.RawItem' class="type">RawItem</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a></code></h4><h4 id='associatedtype.Iter' class="type"><code id='Iter.t'>type <a href='../../nom/trait.InputIter.html#associatedtype.Iter' class="type">Iter</a> = <a class="struct" href="../../nom/lib/std/str/struct.CharIndices.html" title="struct nom::lib::std::str::CharIndices">CharIndices</a>&lt;'a&gt;</code></h4><h4 id='associatedtype.IterElem' class="type"><code id='IterElem.t'>type <a href='../../nom/trait.InputIter.html#associatedtype.IterElem' class="type">IterElem</a> = <a class="struct" href="../../nom/lib/std/str/struct.Chars.html" title="struct nom::lib::std::str::Chars">Chars</a>&lt;'a&gt;</code></h4><h4 id='method.iter_indices' class="method hidden"><code id='iter_indices.v'>fn <a href='../../nom/trait.InputIter.html#tymethod.iter_indices' class='fnname'>iter_indices</a>(&amp;self) -&gt; Self::<a class="type" href="../../nom/trait.InputIter.html#associatedtype.Iter" title="type nom::InputIter::Iter">Iter</a></code><a class='srclink' href='../../src/nom/types.rs.html#99-101' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>returns an iterator over the elements and their byte offsets</p>
</div><h4 id='method.iter_elements' class="method hidden"><code id='iter_elements.v'>fn <a href='../../nom/trait.InputIter.html#tymethod.iter_elements' class='fnname'>iter_elements</a>(&amp;self) -&gt; Self::<a class="type" href="../../nom/trait.InputIter.html#associatedtype.IterElem" title="type nom::InputIter::IterElem">IterElem</a></code><a class='srclink' href='../../src/nom/types.rs.html#102-104' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>returns an iterator over the elements</p>
</div><h4 id='method.position' class="method hidden"><code id='position.v'>fn <a href='../../nom/trait.InputIter.html#tymethod.position' class='fnname'>position</a>&lt;P&gt;(&amp;self, predicate: P) -&gt; <a class="enum" href="../../nom/lib/std/prelude/v1/v1/enum.Option.html" title="enum nom::lib::std::prelude::v1::v1::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Fn.html" title="trait nom::lib::std::prelude::v1::v1::Fn">Fn</a>(Self::<a class="type" href="../../nom/trait.InputIter.html#associatedtype.RawItem" title="type nom::InputIter::RawItem">RawItem</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../../src/nom/types.rs.html#105-110' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>finds the byte position of the element</p>
</div><h4 id='method.slice_index' class="method hidden"><code id='slice_index.v'>fn <a href='../../nom/trait.InputIter.html#tymethod.slice_index' class='fnname'>slice_index</a>(&amp;self, count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="../../nom/lib/std/prelude/v1/v1/enum.Option.html" title="enum nom::lib::std::prelude::v1::v1::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class='srclink' href='../../src/nom/types.rs.html#111-113' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>get the byte offset from the element's position in the stream</p>
</div></div><h3 id='impl-InputTake' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.InputTake.html" title="trait nom::InputTake">InputTake</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-InputTake' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#116-125' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.take' class="method hidden"><code id='take.v'>fn <a href='../../nom/trait.InputTake.html#tymethod.take' class='fnname'>take</a>(&amp;self, count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; Self</code><a class='srclink' href='../../src/nom/types.rs.html#117-119' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>returns a slice of <code>count</code> bytes. panics if count &gt; length</p>
</div><h4 id='method.take_split' class="method hidden"><code id='take_split.v'>fn <a href='../../nom/trait.InputTake.html#tymethod.take_split' class='fnname'>take_split</a>(&amp;self, count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>Self, Self<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a></code><a class='srclink' href='../../src/nom/types.rs.html#121-124' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>split the stream at the <code>count</code> byte offset. panics if count &gt; length</p>
</div></div><h3 id='impl-InputTakeAtPosition' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.InputTakeAtPosition.html" title="trait nom::InputTakeAtPosition">InputTakeAtPosition</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-InputTakeAtPosition' class='anchor'></a><a class='srclink' href='../../src/nom/traits.rs.html#614-647' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Item-1' class="type"><code id='Item.t-1'>type <a href='../../nom/trait.InputTakeAtPosition.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a></code></h4><h4 id='method.split_at_position' class="method hidden"><code id='split_at_position.v'>fn <a href='../../nom/trait.InputTakeAtPosition.html#tymethod.split_at_position' class='fnname'>split_at_position</a>&lt;P&gt;(&amp;self, predicate: P) -&gt; <a class="type" href="../../nom/type.IResult.html" title="type nom::IResult">IResult</a>&lt;Self, Self, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Fn.html" title="trait nom::lib::std::prelude::v1::v1::Fn">Fn</a>(Self::<a class="type" href="../../nom/trait.InputTakeAtPosition.html#associatedtype.Item" title="type nom::InputTakeAtPosition::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../../src/nom/traits.rs.html#617-628' title='goto source code'>[src]</a></h4><h4 id='method.split_at_position1' class="method hidden"><code id='split_at_position1.v'>fn <a href='../../nom/trait.InputTakeAtPosition.html#tymethod.split_at_position1' class='fnname'>split_at_position1</a>&lt;P&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;predicate: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;e: <a class="enum" href="../../nom/enum.ErrorKind.html" title="enum nom::ErrorKind">ErrorKind</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;<br>) -&gt; <a class="type" href="../../nom/type.IResult.html" title="type nom::IResult">IResult</a>&lt;Self, Self, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Fn.html" title="trait nom::lib::std::prelude::v1::v1::Fn">Fn</a>(Self::<a class="type" href="../../nom/trait.InputTakeAtPosition.html#associatedtype.Item" title="type nom::InputTakeAtPosition::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../../src/nom/traits.rs.html#630-646' title='goto source code'>[src]</a></h4></div><h3 id='impl-Compare%3C%26%27b%20str%3E' class='impl'><code class='in-band'>impl&lt;'a, 'b&gt; <a class="trait" href="../../nom/trait.Compare.html" title="trait nom::Compare">Compare</a>&lt;&amp;'b <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Compare%3C%26%27b%20str%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#133-140' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.compare' class="method hidden"><code id='compare.v'>fn <a href='../../nom/trait.Compare.html#tymethod.compare' class='fnname'>compare</a>(&amp;self, t: &amp;'b <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="../../nom/enum.CompareResult.html" title="enum nom::CompareResult">CompareResult</a></code><a class='srclink' href='../../src/nom/types.rs.html#134-136' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>compares self to another value for equality</p>
</div><h4 id='method.compare_no_case' class="method hidden"><code id='compare_no_case.v'>fn <a href='../../nom/trait.Compare.html#tymethod.compare_no_case' class='fnname'>compare_no_case</a>(&amp;self, t: &amp;'b <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="../../nom/enum.CompareResult.html" title="enum nom::CompareResult">CompareResult</a></code><a class='srclink' href='../../src/nom/types.rs.html#137-139' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>compares self to another value for equality independently of the case. <a href="../../nom/trait.Compare.html#tymethod.compare_no_case">Read more</a></p>
</div></div><h3 id='impl-FindToken%3Cchar%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.FindToken.html" title="trait nom::FindToken">FindToken</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-FindToken%3Cchar%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#148-152' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.find_token' class="method hidden"><code id='find_token.v'>fn <a href='../../nom/trait.FindToken.html#tymethod.find_token' class='fnname'>find_token</a>(&amp;self, token: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/nom/types.rs.html#149-151' title='goto source code'>[src]</a></h4></div><h3 id='impl-FindToken%3Cu8%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.FindToken.html" title="trait nom::FindToken">FindToken</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-FindToken%3Cu8%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#154-158' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.find_token-1' class="method hidden"><code id='find_token.v-1'>fn <a href='../../nom/trait.FindToken.html#tymethod.find_token' class='fnname'>find_token</a>(&amp;self, token: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/nom/types.rs.html#155-157' title='goto source code'>[src]</a></h4></div><h3 id='impl-FindToken%3C%26%27a%20u8%3E' class='impl'><code class='in-band'>impl&lt;'a, 'b&gt; <a class="trait" href="../../nom/trait.FindToken.html" title="trait nom::FindToken">FindToken</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'b&gt;</code><a href='#impl-FindToken%3C%26%27a%20u8%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#160-164' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.find_token-2' class="method hidden"><code id='find_token.v-2'>fn <a href='../../nom/trait.FindToken.html#tymethod.find_token' class='fnname'>find_token</a>(&amp;self, token: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/nom/types.rs.html#161-163' title='goto source code'>[src]</a></h4></div><h3 id='impl-FindSubstring%3C%26%27b%20str%3E' class='impl'><code class='in-band'>impl&lt;'a, 'b&gt; <a class="trait" href="../../nom/trait.FindSubstring.html" title="trait nom::FindSubstring">FindSubstring</a>&lt;&amp;'b <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-FindSubstring%3C%26%27b%20str%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#142-146' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.find_substring' class="method hidden"><code id='find_substring.v'>fn <a href='../../nom/trait.FindSubstring.html#tymethod.find_substring' class='fnname'>find_substring</a>(&amp;self, substr: &amp;'b <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="../../nom/lib/std/prelude/v1/v1/enum.Option.html" title="enum nom::lib::std::prelude::v1::v1::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class='srclink' href='../../src/nom/types.rs.html#143-145' title='goto source code'>[src]</a></h4></div><h3 id='impl-ParseTo%3CR%3E' class='impl'><code class='in-band'>impl&lt;'a, R:&nbsp;<a class="trait" href="../../nom/lib/std/str/trait.FromStr.html" title="trait nom::lib::std::str::FromStr">FromStr</a>&gt; <a class="trait" href="../../nom/trait.ParseTo.html" title="trait nom::ParseTo">ParseTo</a>&lt;R&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-ParseTo%3CR%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#166-170' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.parse_to' class="method hidden"><code id='parse_to.v'>fn <a href='../../nom/trait.ParseTo.html#tymethod.parse_to' class='fnname'>parse_to</a>(&amp;self) -&gt; <a class="enum" href="../../nom/lib/std/prelude/v1/v1/enum.Option.html" title="enum nom::lib::std::prelude::v1::v1::Option">Option</a>&lt;R&gt;</code><a class='srclink' href='../../src/nom/types.rs.html#167-169' title='goto source code'>[src]</a></h4></div><h3 id='impl-Slice%3CRange%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.Slice.html" title="trait nom::Slice">Slice</a>&lt;<a class="struct" href="../../nom/lib/std/ops/struct.Range.html" title="struct nom::lib::std::ops::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Slice%3CRange%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#65-70' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.slice' class="method hidden"><code id='slice.v'>fn <a href='../../nom/trait.Slice.html#tymethod.slice' class='fnname'>slice</a>(&amp;self, range: <a class="struct" href="../../nom/lib/std/ops/struct.Range.html" title="struct nom::lib::std::ops::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; Self</code><a class='srclink' href='../../src/nom/types.rs.html#67-69' title='goto source code'>[src]</a></h4></div><h3 id='impl-Slice%3CRangeTo%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.Slice.html" title="trait nom::Slice">Slice</a>&lt;<a class="struct" href="../../nom/lib/std/ops/struct.RangeTo.html" title="struct nom::lib::std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Slice%3CRangeTo%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#72-77' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.slice-1' class="method hidden"><code id='slice.v-1'>fn <a href='../../nom/trait.Slice.html#tymethod.slice' class='fnname'>slice</a>(&amp;self, range: <a class="struct" href="../../nom/lib/std/ops/struct.RangeTo.html" title="struct nom::lib::std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; Self</code><a class='srclink' href='../../src/nom/types.rs.html#74-76' title='goto source code'>[src]</a></h4></div><h3 id='impl-Slice%3CRangeFrom%3Cusize%3E%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.Slice.html" title="trait nom::Slice">Slice</a>&lt;<a class="struct" href="../../nom/lib/std/ops/struct.RangeFrom.html" title="struct nom::lib::std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Slice%3CRangeFrom%3Cusize%3E%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#79-84' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.slice-2' class="method hidden"><code id='slice.v-2'>fn <a href='../../nom/trait.Slice.html#tymethod.slice' class='fnname'>slice</a>(&amp;self, range: <a class="struct" href="../../nom/lib/std/ops/struct.RangeFrom.html" title="struct nom::lib::std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; Self</code><a class='srclink' href='../../src/nom/types.rs.html#81-83' title='goto source code'>[src]</a></h4></div><h3 id='impl-Slice%3CRangeFull%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.Slice.html" title="trait nom::Slice">Slice</a>&lt;<a class="struct" href="../../nom/lib/std/ops/struct.RangeFull.html" title="struct nom::lib::std::ops::RangeFull">RangeFull</a>&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Slice%3CRangeFull%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#86-91' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.slice-3' class="method hidden"><code id='slice.v-3'>fn <a href='../../nom/trait.Slice.html#tymethod.slice' class='fnname'>slice</a>(&amp;self, range: <a class="struct" href="../../nom/lib/std/ops/struct.RangeFull.html" title="struct nom::lib::std::ops::RangeFull">RangeFull</a>) -&gt; Self</code><a class='srclink' href='../../src/nom/types.rs.html#88-90' title='goto source code'>[src]</a></h4></div><h3 id='impl-AtEof' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.AtEof.html" title="trait nom::AtEof">AtEof</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-AtEof' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#58-63' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.at_eof' class="method hidden"><code id='at_eof.v'>fn <a href='../../nom/trait.AtEof.html#tymethod.at_eof' class='fnname'>at_eof</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/nom/types.rs.html#60-62' title='goto source code'>[src]</a></h4></div><h3 id='impl-ExtendInto' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/trait.ExtendInto.html" title="trait nom::ExtendInto">ExtendInto</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-ExtendInto' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#185-197' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Item-2' class="type"><code id='Item.t-2'>type <a href='../../nom/trait.ExtendInto.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a></code></h4><h4 id='associatedtype.Extender' class="type"><code id='Extender.t'>type <a href='../../nom/trait.ExtendInto.html#associatedtype.Extender' class="type">Extender</a> = <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a></code></h4><h4 id='method.new_builder' class="method hidden"><code id='new_builder.v'>fn <a href='../../nom/trait.ExtendInto.html#tymethod.new_builder' class='fnname'>new_builder</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a></code><a class='srclink' href='../../src/nom/types.rs.html#190-192' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>create a new <code>Extend</code> of the correct type</p>
</div><h4 id='method.extend_into' class="method hidden"><code id='extend_into.v'>fn <a href='../../nom/trait.ExtendInto.html#tymethod.extend_into' class='fnname'>extend_into</a>(&amp;self, acc: &amp;mut <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a>)</code><a class='srclink' href='../../src/nom/types.rs.html#194-196' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>accumulate the input into an accumulator</p>
</div></div><h3 id='impl-AsRef%3Cstr%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.AsRef.html" title="trait nom::lib::std::prelude::v1::v1::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-AsRef%3Cstr%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#43-47' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.as_ref' class="method hidden"><code id='as_ref.v'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.AsRef.html#tymethod.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><a class='srclink' href='../../src/nom/types.rs.html#44-46' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Clone' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Clone.html" title="trait nom::lib::std::prelude::v1::v1::Clone">Clone</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Clone' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.clone' class="method hidden"><code id='clone.v'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="../../nom/lib/std/prelude/v1/v1/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method"><code id='clone_from.v'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/clone.rs.html#131-133' title='goto source code'>[src]</a></h4><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="../../nom/lib/std/prelude/v1/v1/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id='impl-From%3C%26%27a%20str%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.From.html" title="trait nom::lib::std::prelude::v1::v1::From">From</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-From%3C%26%27a%20str%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#25-29' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code id='from.v'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.From.html#tymethod.from' class='fnname'>from</a>(src: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; Self</code><a class='srclink' href='../../src/nom/types.rs.html#26-28' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3C%26%27b%20%26%27a%20str%3E' class='impl'><code class='in-band'>impl&lt;'a, 'b&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.From.html" title="trait nom::lib::std::prelude::v1::v1::From">From</a>&lt;&amp;'b &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-From%3C%26%27b%20%26%27a%20str%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#31-35' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-1' class="method hidden"><code id='from.v-1'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.From.html#tymethod.from' class='fnname'>from</a>(src: &amp;'b &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; Self</code><a class='srclink' href='../../src/nom/types.rs.html#32-34' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Eq' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Eq.html" title="trait nom::lib::std::prelude::v1::v1::Eq">Eq</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Eq' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Copy' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Copy.html" title="trait nom::lib::std::prelude::v1::v1::Copy">Copy</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Copy' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-PartialEq%3CCompleteStr%3C%27a%3E%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.PartialEq.html" title="trait nom::lib::std::prelude::v1::v1::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;&gt; for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-PartialEq%3CCompleteStr%3C%27a%3E%3E' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.eq' class="method hidden"><code id='eq.v'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../../nom/lib/std/prelude/v1/v1/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne' class="method hidden"><code id='ne.v'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;<a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-Deref' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/ops/trait.Deref.html" title="trait nom::lib::std::ops::Deref">Deref</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Deref' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#49-56' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Target' class="type"><code id='Target.t'>type <a href='../../nom/lib/std/ops/trait.Deref.html#associatedtype.Target' class="type">Target</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></h4><div class='docblock'><p>The resulting type after dereferencing.</p>
</div><h4 id='method.deref' class="method hidden"><code id='deref.v'>fn <a href='../../nom/lib/std/ops/trait.Deref.html#tymethod.deref' class='fnname'>deref</a>(&amp;self) -&gt; &amp;Self::<a class="type" href="../../nom/lib/std/ops/trait.Deref.html#associatedtype.Target" title="type nom::lib::std::ops::Deref::Target">Target</a></code><a class='srclink' href='../../src/nom/types.rs.html#53-55' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Dereferences the value.</p>
</div></div><h3 id='impl-Debug' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/fmt/trait.Debug.html" title="trait nom::lib::std::fmt::Debug">Debug</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code id='fmt.v'>fn <a href='../../nom/lib/std/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../nom/lib/std/fmt/struct.Formatter.html" title="struct nom::lib::std::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="../../nom/lib/std/fmt/type.Result.html" title="type nom::lib::std::fmt::Result">Result</a></code><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="../../nom/lib/std/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Display' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/fmt/trait.Display.html" title="trait nom::lib::std::fmt::Display">Display</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Display' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#37-41' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt-1' class="method hidden"><code id='fmt.v-1'>fn <a href='../../nom/lib/std/fmt/trait.Display.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../nom/lib/std/fmt/struct.Formatter.html" title="struct nom::lib::std::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="../../nom/lib/std/fmt/type.Result.html" title="type nom::lib::std::fmt::Result">Result</a></code><a class='srclink' href='../../src/nom/types.rs.html#38-40' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="../../nom/lib/std/fmt/trait.Display.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Hash' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/hash/trait.Hash.html" title="trait nom::lib::std::hash::Hash">Hash</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Hash' class='anchor'></a><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.hash' class="method hidden"><code id='hash.v'>fn <a href='../../nom/lib/std/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;__H:&nbsp;<a class="trait" href="../../nom/lib/std/hash/trait.Hasher.html" title="trait nom::lib::std::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>__H)</code><a class='srclink' href='../../src/nom/types.rs.html#22' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Feeds this value into the given [<code>Hasher</code>]. <a href="../../nom/lib/std/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div><h4 id='method.hash_slice' class="method"><code id='hash_slice.v'>fn <a href='../../nom/lib/std/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="../../nom/lib/std/hash/trait.Hasher.html" title="trait nom::lib::std::hash::Hasher">Hasher</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.3.0'>1.3.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#192-198' title='goto source code'>[src]</a></h4><div class='docblock'><p>Feeds a slice of this type into the given [<code>Hasher</code>]. <a href="../../nom/lib/std/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-Send' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Send.html" title="trait nom::lib::std::prelude::v1::v1::Send">Send</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Send' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Sync.html" title="trait nom::lib::std::prelude::v1::v1::Sync">Sync</a> for <a class="struct" href="../../nom/types/struct.CompleteStr.html" title="struct nom::types::CompleteStr">CompleteStr</a>&lt;'a&gt;</code><a href='#impl-Sync' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-ToString' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.ToString.html" title="trait nom::lib::std::prelude::v1::v1::ToString">ToString</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../nom/lib/std/fmt/trait.Display.html" title="trait nom::lib::std::fmt::Display">Display</a> + ?<a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Sized.html" title="trait nom::lib::std::prelude::v1::v1::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-ToString' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2122-2132' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_string' class="method hidden"><code id='to_string.v'>default fn <a href='../../nom/lib/std/prelude/v1/v1/trait.ToString.html#tymethod.to_string' class='fnname'>to_string</a>(&amp;self) -&gt; <a class="struct" href="../../nom/lib/std/prelude/v1/v1/struct.String.html" title="struct nom::lib::std::prelude::v1::v1::String">String</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2124-2131' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Converts the given value to a <code>String</code>. <a href="../../nom/lib/std/prelude/v1/v1/trait.ToString.html#tymethod.to_string">Read more</a></p>
</div></div><h3 id='impl-From%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.From.html" title="trait nom::lib::std::prelude::v1::v1::From">From</a>&lt;T&gt; for T</code><a href='#impl-From%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#546-548' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-2' class="method hidden"><code id='from.v-2'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#547' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Into.html" title="trait nom::lib::std::prelude::v1::v1::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.From.html" title="trait nom::lib::std::prelude::v1::v1::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#537-542' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code id='into.v'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#539-541' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-ToOwned' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.ToOwned.html" title="trait nom::lib::std::prelude::v1::v1::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Clone.html" title="trait nom::lib::std::prelude::v1::v1::Clone">Clone</a>,&nbsp;</span></code><a href='#impl-ToOwned' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#81-92' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Owned' class="type"><code id='Owned.t'>type <a href='../../nom/lib/std/prelude/v1/v1/trait.ToOwned.html#associatedtype.Owned' class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id='method.to_owned' class="method hidden"><code id='to_owned.v'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.ToOwned.html#tymethod.to_owned' class='fnname'>to_owned</a>(&amp;self) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#85-87' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="../../nom/lib/std/prelude/v1/v1/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id='method.clone_into' class="method hidden"><code id='clone_into.v'>fn <a href='../../nom/lib/std/prelude/v1/v1/trait.ToOwned.html#method.clone_into' class='fnname'>clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89-91' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="../../nom/lib/std/prelude/v1/v1/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id='impl-TryFrom%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../../nom/lib/std/convert/trait.TryFrom.html" title="trait nom::lib::std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Into.html" title="trait nom::lib::std::prelude::v1::v1::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#565-571' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code id='Error.t'>type <a href='../../nom/lib/std/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="../../nom/lib/std/convert/enum.Infallible.html" title="enum nom::lib::std::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code id='try_from.v'>fn <a href='../../nom/lib/std/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="../../nom/lib/std/prelude/v1/v1/enum.Result.html" title="enum nom::lib::std::prelude::v1::v1::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../nom/lib/std/convert/trait.TryFrom.html" title="trait nom::lib::std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../../nom/lib/std/convert/trait.TryFrom.html#associatedtype.Error" title="type nom::lib::std::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#568-570' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryInto%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../../nom/lib/std/convert/trait.TryInto.html" title="trait nom::lib::std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../nom/lib/std/convert/trait.TryFrom.html" title="trait nom::lib::std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#553-560' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code id='Error.t-1'>type <a href='../../nom/lib/std/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="../../nom/lib/std/convert/trait.TryFrom.html" title="trait nom::lib::std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../../nom/lib/std/convert/trait.TryFrom.html#associatedtype.Error" title="type nom::lib::std::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code id='try_into.v'>fn <a href='../../nom/lib/std/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="../../nom/lib/std/prelude/v1/v1/enum.Result.html" title="enum nom::lib::std::prelude::v1::v1::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../nom/lib/std/convert/trait.TryFrom.html" title="trait nom::lib::std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../../nom/lib/std/convert/trait.TryFrom.html#associatedtype.Error" title="type nom::lib::std::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#557-559' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-BorrowMut%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Sized.html" title="trait nom::lib::std::prelude::v1::v1::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-220' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>I</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>I</h3><code class="content"><span class="where fmt-newline">impl&lt;'_, I&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>I <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> + ?<a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Sized.html" title="trait nom::lib::std::prelude::v1::v1::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &lt;I as <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a>&gt;::<a class="type" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item" title="type nom::lib::std::prelude::v1::v1::Iterator::Item">Item</a>;</span></code></div></div><code id='borrow_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-Borrow%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Sized.html" title="trait nom::lib::std::prelude::v1::v1::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#213-215' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>I</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>I</h3><code class="content"><span class="where fmt-newline">impl&lt;'_, I&gt; <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'_ mut </a>I <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a> + ?<a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Sized.html" title="trait nom::lib::std::prelude::v1::v1::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &lt;I as <a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html" title="trait nom::lib::std::prelude::v1::v1::Iterator">Iterator</a>&gt;::<a class="type" href="../../nom/lib/std/prelude/v1/v1/trait.Iterator.html#associatedtype.Item" title="type nom::lib::std::prelude::v1::v1::Iterator::Item">Item</a>;</span></code></div></div><code id='borrow.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="../../nom/lib/std/prelude/v1/v1/trait.Sized.html" title="trait nom::lib::std::prelude::v1::v1::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#100-102' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code id='type_id.v'>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#101' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../";window.currentCrate = "nom";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>